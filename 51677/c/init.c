/*******************************************************************************
//                   ArthroCare Proprietary and Confidential
//                   (c) ArthroCare Corporation 2012
//                           All Rights Reserved
********************************************************************************
$Author:: Harshil.Shah      $:
$Rev:: 2818                 $:
$Date:: 2022-02-21 12:55:09#$:

CPU:               Freescale Kinetis P/N MK60FN1M0VLQ15 (144-Pin), REVID ?
Compiler:          IAR ANSI C/C++ Compiler for ARM 6.50
*******************************************************************************/

/***************************************************************************//**
\file:     init.c
\brief     initialize system
\details   Load volume data from flash during power up, reinitialize global
program variables, and manage initialization of system modules.
*******************************************************************************/

#include "pit.h"
#include "pump.h"
#include "audio.h"
#include "wand.h"
#include "footpedal.h"
#include "init.h"
#include "can.h"
#include "adc.h"
#include "psu.h"
#include "led.h"
#include "rtc.h"
#include "wdog.h"
#include "cpu.h"
#include "crc.h"
#include "legacy_wand.h"
#include "sw_manager.h"
#include "ftfe.h"

extern previous_wands previous_wands_database[LW_DB_SZ];
extern uint8_t current_coag_setpoint;
extern manta_prime prime;

/****************************************************************************//**
Adds events to the event queue. The events are usually generated by ISRs.
@param void
@return uint8_t zero 
@outputs
@context called after board is powered following POWER_UP event in powerup state
********************************************************************************/
uint8_t sys_init(void)
{
//  program_ftfe_partition (); 
//  set_ftfe_function ();
  nonvolatile_data_layout *p_data = (nonvolatile_data_layout*)NONVOLATILE_DATA_ADDRESS;
  uint16_t nwords = (sizeof(nonvolatile_data_layout) + 15) >> 4;
  uint16_t nbytes = 0; 
  uint16_t nv_data_crc = 0;
  //while(( FTFE_FCNFG & FTFE_FCNFG_EEERDY_MASK) == 0);  

  /* calculate num bytes being stored in nv memory */
  if (p_data->nwords <= 255)
  {
    
    /* each word is 16 bytes */
    nbytes = p_data->nwords << 4;
    
  }
  
  /* Default settings */
  current_therapy_settings.pulsing.irms_peak = 0xFF;
  current_therapy_settings.treatment.therapy_mode = LO;
  current_therapy_settings.treatment.previous_therapy_mode = LO;
  current_therapy_settings.setpoint.lo = ABLATE_DEFAULT;
  current_therapy_settings.setpoint.med = ABLATE_DEFAULT;
  current_therapy_settings.setpoint.hi = ABLATE_DEFAULT;
  current_therapy_settings.setpoint.coag = COAG_1;
  current_therapy_settings.ambient.capable = 0;
  current_therapy_settings.treatment.ablate_enable = TRUE;
  /*
    @ENT
    default without knowing what type of generator we are
    default flow rate and auto-prime
  */
  current_therapy_settings.controller = UNKNOWN_GEN;
  current_therapy_settings.active_wand.smart_wand = UNKNOWN_GEN;
  current_therapy_settings.active_wand.legacy_wand = UNKNOWN_GEN;
  current_therapy_settings.treatment.flow_rate = DEFAULT_FLOW_RATE;
  current_therapy_settings.treatment.flow_auto = TRUE;
      
  if (p_data->active_app_ptr == 0x40004)
  {
    
    pheader = (program_header*)0x40004;
    
  }
  else
  {
    
    pheader = (program_header*)0x10004;
    
  }
  
  if (nbytes > 1)
  {
    /* calculate checksum */
    nv_data_crc = fast_crc16(nv_data_crc,
                             (uint8_t*)NONVOLATILE_DATA_ADDRESS+2, 
                             nbytes-2); 
  }
  
  
  if ((p_data->checksum == nv_data_crc) && (p_data->nwords == nwords))
  {
    
    current_therapy_settings.user_data = p_data->user_data;
    current_therapy_settings.rtc.power_down_time = p_data->rtc;
    current_therapy_settings.rtc.tamper_detected = p_data->vbatt_tamper_detect;

    
    for (uint8_t i = 0; i < LW_DB_SZ; i++)
    {
      previous_wands_database[i].activation_time_sum = 
        p_data->nv_previous_wands_database[i].activation_time_sum;
        
       previous_wands_database[i].R1_wand_type = 
         p_data->nv_previous_wands_database[i].R1_wand_type;
       
      previous_wands_database[i].R2_adc_value = 
        p_data->nv_previous_wands_database[i].R2_adc_value;
      
      previous_wands_database[i].start_time = 
        p_data->nv_previous_wands_database[i].start_time;
    }
    
    load_default_volume(p_data->master_volume,p_data->ambient_volume);
    current_therapy_settings.gui.languageID = load_default_language(p_data->languageID);
    if (p_data->wireless_married_latch == 1)
    {
      current_therapy_settings.footpedal.wireless.married_latch = 1;
      if (p_data->wireless_en == 1)
      {
        current_therapy_settings.treatment.wireless_enable = (bool)1;
      }
    }
    /* test boundaries; guard against erroneous data */
    if (pheader->params.wireless_pair_timeout != 0xFFFFFFFF)
    {
      current_therapy_settings.footpedal.wireless.pair_timeout = 
      pheader->params.wireless_pair_timeout;
    }
    else
    {
      current_therapy_settings.footpedal.wireless.pair_timeout = 0;
    }
  }
  else
  {
    
    current_therapy_settings.rtc.tamper_detected = 0;
    current_therapy_settings.rtc.power_down_time = 0;
    current_therapy_settings.audio.volume = 5;
    current_therapy_settings.ambient.volume = 5;
    current_therapy_settings.gui.languageID = ENGLISH;
    current_therapy_settings.treatment.wireless_enable = (bool) 0;
    current_therapy_settings.footpedal.wireless.married_latch = 0;
    current_therapy_settings.footpedal.wireless.pair_timeout = 0;
  }
  
  current_therapy_settings.sw.app1_version_major = p_data->app1_version_major;
  current_therapy_settings.sw.app1_version_minor = p_data->app1_version_minor;
  current_therapy_settings.sw.app2_version_major = p_data->app2_version_major;
  current_therapy_settings.sw.app2_version_minor = p_data->app2_version_minor;

  current_therapy_settings.user_data.settings.idx_b4_pwr_cycle = 
    current_therapy_settings.user_data.settings.active_idx;
  current_therapy_settings.user_data.settings.active_idx = 0;
  current_therapy_settings.ambient.alarm_threshold = 45;
  current_therapy_settings.ambient.audio_enabled = 1;
  current_therapy_settings.ambient.enable = 1;
  current_therapy_settings.ambient.enable_user_pref = 1;
  current_therapy_settings.treatment.finger_switch_en = (bool)1;
  current_therapy_settings.ambient.thermometer_color = 2;
  current_therapy_settings.previous_wand_indication = p_data->previous_wand_indication;
  
  if(current_therapy_settings.previous_wand_indication == SMART_WAND_MFG_INDICATION_MANTA)
  {
    current_therapy_settings.setpoint.coag = p_data->previous_wand_coag;
    current_coag_setpoint = current_therapy_settings.setpoint.coag;
    current_therapy_settings.treatment.flow_rate = p_data->previous_wand_flow_rate;
    current_therapy_settings.pump.ent_flow = change_flow_manta(current_therapy_settings.setpoint.coag, 
                                                               current_therapy_settings.treatment.flow_rate);
    
  }
  
  //current_therapy_settings.treatment.wireless_enable = (bool) 0;
  current_therapy_settings.user_data.profile[0].record_full = save_profile(0);
  
    

  
      
  PORTD_PCR9 = PORT_PCR_MUX(1); // wand select
  PORTD_PCR10 = PORT_PCR_MUX(1); // pilot
  
  /* Set pins as outputs */
  GPIOD_PDDR |= GPIO_PDDR_PDD(WAND_OUTPUT_SELECT | WAND_PILOT_SELECT);
  GPIOD_PCOR |= GPIO_PDOR_PDO(WAND_OUTPUT_SELECT | WAND_PILOT_SELECT);
  

 
  
  /* copy rtc_tsr to ram */
  current_therapy_settings.log.start_time = rtc_init();
  
  put_event(&evt_tbl,INIT_MANAGER);
    
  return 0;
  
}


/****************************************************************************//**
schedule various initialization events in a specific order.
@param void
@return uint8_t exit_init when initialization is complete.
@outputs introduce initialization events in the following order: low-power timer
(lpt), direct memory access (dma) mux, systick timer in core, pwm for audio,
quadrature decoder for volume knob, pwm for audio tones, digital i/o for foot
switch, digital-to-analog (dac) control for variable DC output (+VMOD), serial
interface for smart wand, internal adc, CAN to communicate reset programmable
interrupt timers (pit), enable pit irq's, @context called right after board is powered during powerup state.
********************************************************************************/
uint8_t init_manager(void)
{
  
  /* start init idx w/ dma mux */
  static event init_event_idx = INIT_LPT;
  uint8_t exit_init = 0;
  uint32_t seconds_1 = 0;
  static uint32_t seconds_2 = 0;
  
  if (init_event_idx == INIT_MANAGER)
  {
        
    /* reset & enable irq's for pit's */    
    RESET_PIT(0);
    RESET_PIT(1);
    RESET_PIT(2);
    //RESET_PIT(3);

    /* Enable pit0 irq */
    NVIC_EnableIRQ(PIT0_IRQn);

    /* Enable pit1 irq */
    NVIC_EnableIRQ(PIT1_IRQn);
    //DISABLE_PIT(1);

    /* Enable pit2 irq */
    NVIC_EnableIRQ(PIT2_IRQn);

    /* Enable pit3 irq */
    //NVIC_EnableIRQ(PIT0_IRQn);
    
    /* run init manager one last time to exit */
    put_event(&evt_tbl,INIT_MANAGER);

    /* set next init event */
    init_event_idx++;
    
  }
  else if (init_event_idx > INIT_AUDIO_AMP)
  {
    
    exit_init = 1;
    init_event_idx = INIT_LED;
    
  }
  else if (init_event_idx == INIT_LED)
  {
    
    /* copy RTC_TSR to ram */
    seconds_1 = (*(uint32_t*)0x4003D000);
    
    if (seconds_1 > seconds_2 + 3)
    {
      
      seconds_2 = seconds_1;

    }      
     
    if (seconds_1 >= seconds_2 + 3)
    {

      put_event(&evt_tbl,INIT_LED);

      init_event_idx++;
      
    }
    else
    {
      
      /* run init manager one last time to exit */
      put_event(&evt_tbl,INIT_MANAGER);
    
    }
    
  } 
  else if (init_event_idx != INIT_LED)
  {
      
    put_event(&evt_tbl,init_event_idx);

    /* set next init event */
    init_event_idx++;
    
  }
      
  return exit_init;
  
}


SUPPORTED_LANGUAGES load_default_language(uint8_t langID)
{
  
  SUPPORTED_LANGUAGES default_langID = (SUPPORTED_LANGUAGES)langID;
  
  if (langID >= MAX_NUM_LANGUAGES)
  {
    
    default_langID = ENGLISH;
    
  }
  
  return default_langID;
  
}
