/*******************************************************************************
                   ArthroCare Proprietary and Confidential
                   (c) ArthroCare Corporation 2012
                           All Rights Reserved
********************************************************************************
$Author:: Harshil.Shah      $:
$Rev:: 2798                 $:
$Date:: 2021-11-17 02:10:26#$:

CPU:               Freescale Kinetis P/N MK60FN1M0VLQ15 (144-Pin), REVID ?
Compiler:          IAR ANSI C/C++ Compiler for ARM 6.50
*******************************************************************************/
/***************************************************************************//**
\file:     event_buffer.c
\brief     A queue for system events
\details   This buffer is shared between the asynchronous and synchronous space.
The write and read from the buffer are atomic (isrs) are disabled before
accessing the buffer
*******************************************************************************/
#include "event_buffer.h"
#include <string.h>
/***************************************************************************//**
Adds events to the event queue. The events are usually generated by ISRs.
@param evt_tbl pointer to event buffer
@param e event
@return uint8_t status 1 for success
@outputs
@context Save and restore interrupt state when adding events
*******************************************************************************/
uint8_t
put_event (event_table *evt_tbl, event e)
{
  uint8_t status = 0U;
  
/*******************************************************************************
 * Note:
 * Save interrupt state so when re-enabled anything that was disabled will
 * remain disabled.
 ******************************************************************************/
  __istate_t s = __get_interrupt_state();
  __disable_interrupt();
  if (evt_tbl->index < ((uint8_t)EVENT_BUFFER_SIZE))
  {

    evt_tbl->buff[evt_tbl->index++] = e;
    status = 1U;
      
  }
  else
  {
    /* log some error */
    asm("nop");
  }
  /* restore interrupt state */  
  __set_interrupt_state(s);
  return status;
}

/****************************************************************************//**
Removes and returns events from the event queue. The events are consumed by
the state machine
@param evt_tbl pointer to event buffer
@return e event
@outputs
@context Save and restore interrupt state when popping events
********************************************************************************/
event
get_event (event_table *p_evt_tbl)
{
  event e = NULL_EVENT;
/*******************************************************************************
 * Note:
 * Save interrupt state so when re-enabled anything that was disabled will
 * remain disabled.
 ******************************************************************************/
  __istate_t s = __get_interrupt_state();
  __disable_interrupt();
  if ((p_evt_tbl->index > 0U)) 
  {

    /* pop event */
    e =  p_evt_tbl->buff[0];
    p_evt_tbl->index--;
    memcpy(&p_evt_tbl->buff[0],&p_evt_tbl->buff[1],(uint8_t)(EVENT_BUFFER_SIZE-1));
    p_evt_tbl->buff[EVENT_BUFFER_SIZE-1] = NULL_EVENT;
    
  }
  else
  {
    
    /* memset(p_evt_tbl,0,sizeof(event_table)); */
    
  }
  __set_interrupt_state(s);
  return e;
}

/*
uint8_t put_event (event_table *evt_tbl, event e)
{
  uint8_t status = 0;
  evt_tbl->buff[evt_tbl->producer_index++] = e;
  
  if (evt_tbl->producer_index > (EVENT_BUFFER_SIZE))
  {
    evt_tbl->producer_index = 0;
  }
  return status;
}

event get_event (event_table *evt_tbl)
{
  event e = NULL_EVENT;
  e =  evt_tbl->buff[evt_tbl->consumer_index++];
  if (evt_tbl->consumer_index > EVENT_BUFFER_SIZE  )
  {
    // Circle around to the beginning
    evt_tbl->consumer_index = 0;
  }
  return e;
}


void flush_buffer(event_table* evt_tbl)
{
  evt_tbl->consumer_index = 0;
  evt_tbl->producer_index = 0;
}
  


uint8_t is_empty (event_table *evt_tbl)
{
  return (evt_tbl->index);
}

uint8_t is_full (event_table *evt_tbl)
{
  uint8_t status = 0;
  if (evt_tbl->index == EVENT_BUFFER_SIZE)
  {
    status = 1;
  }
  return status;
}

*/