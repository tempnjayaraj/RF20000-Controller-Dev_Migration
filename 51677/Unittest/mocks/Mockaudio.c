/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "unity.h"
#include "cmock.h"
#include "Mockaudio.h"

typedef struct _CMOCK_audio_amp_init_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_audio_amp_init_CALL_INSTANCE;

typedef struct _CMOCK_LM48100Q_I2C_StartTransmission_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t Expected_cmock_arg1;

} CMOCK_LM48100Q_I2C_StartTransmission_CALL_INSTANCE;

typedef struct _CMOCK_audio_pwm_init_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_audio_pwm_init_CALL_INSTANCE;

typedef struct _CMOCK_Audio_PWM_DMA_Init_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;

} CMOCK_Audio_PWM_DMA_Init_CALL_INSTANCE;

typedef struct _CMOCK_poll_volume_ctrl_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_poll_volume_ctrl_CALL_INSTANCE;

typedef struct _CMOCK_audio_vol_ctrl_init_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_audio_vol_ctrl_init_CALL_INSTANCE;

typedef struct _CMOCK_audible_click_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_audible_click_CALL_INSTANCE;

typedef struct _CMOCK_audio_alarmsound_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;

} CMOCK_audio_alarmsound_CALL_INSTANCE;

typedef struct _CMOCK_reset_alarm_audio_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_reset_alarm_audio_CALL_INSTANCE;

typedef struct _CMOCK_play_change_mode_audio_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_play_change_mode_audio_CALL_INSTANCE;

typedef struct _CMOCK_continuous_audio_pwm_dma_init_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint16_t Expected_cmock_arg1;

} CMOCK_continuous_audio_pwm_dma_init_CALL_INSTANCE;

typedef struct _CMOCK_set_volume_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_set_volume_CALL_INSTANCE;

typedef struct _CMOCK_set_lm48100q_volume_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t Expected_cmock_arg1;

} CMOCK_set_lm48100q_volume_CALL_INSTANCE;

typedef struct _CMOCK_load_default_volume_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t Expected_cmock_arg1;
  uint8_t Expected_cmock_arg2;

} CMOCK_load_default_volume_CALL_INSTANCE;

static struct MockaudioInstance
{
  int audio_amp_init_IgnoreBool;
  uint8_t audio_amp_init_FinalReturn;
  CMOCK_audio_amp_init_CALLBACK audio_amp_init_CallbackFunctionPointer;
  int audio_amp_init_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE audio_amp_init_CallInstance;
  int LM48100Q_I2C_StartTransmission_IgnoreBool;
  CMOCK_LM48100Q_I2C_StartTransmission_CALLBACK LM48100Q_I2C_StartTransmission_CallbackFunctionPointer;
  int LM48100Q_I2C_StartTransmission_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE LM48100Q_I2C_StartTransmission_CallInstance;
  int audio_pwm_init_IgnoreBool;
  uint8_t audio_pwm_init_FinalReturn;
  CMOCK_audio_pwm_init_CALLBACK audio_pwm_init_CallbackFunctionPointer;
  int audio_pwm_init_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE audio_pwm_init_CallInstance;
  int Audio_PWM_DMA_Init_IgnoreBool;
  CMOCK_Audio_PWM_DMA_Init_CALLBACK Audio_PWM_DMA_Init_CallbackFunctionPointer;
  int Audio_PWM_DMA_Init_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE Audio_PWM_DMA_Init_CallInstance;
  int poll_volume_ctrl_IgnoreBool;
  uint8_t poll_volume_ctrl_FinalReturn;
  CMOCK_poll_volume_ctrl_CALLBACK poll_volume_ctrl_CallbackFunctionPointer;
  int poll_volume_ctrl_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE poll_volume_ctrl_CallInstance;
  int audio_vol_ctrl_init_IgnoreBool;
  uint8_t audio_vol_ctrl_init_FinalReturn;
  CMOCK_audio_vol_ctrl_init_CALLBACK audio_vol_ctrl_init_CallbackFunctionPointer;
  int audio_vol_ctrl_init_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE audio_vol_ctrl_init_CallInstance;
  int audible_click_IgnoreBool;
  uint8_t audible_click_FinalReturn;
  CMOCK_audible_click_CALLBACK audible_click_CallbackFunctionPointer;
  int audible_click_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE audible_click_CallInstance;
  int audio_alarmsound_IgnoreBool;
  CMOCK_audio_alarmsound_CALLBACK audio_alarmsound_CallbackFunctionPointer;
  int audio_alarmsound_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE audio_alarmsound_CallInstance;
  int reset_alarm_audio_IgnoreBool;
  uint8_t reset_alarm_audio_FinalReturn;
  CMOCK_reset_alarm_audio_CALLBACK reset_alarm_audio_CallbackFunctionPointer;
  int reset_alarm_audio_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE reset_alarm_audio_CallInstance;
  int play_change_mode_audio_IgnoreBool;
  uint8_t play_change_mode_audio_FinalReturn;
  CMOCK_play_change_mode_audio_CALLBACK play_change_mode_audio_CallbackFunctionPointer;
  int play_change_mode_audio_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE play_change_mode_audio_CallInstance;
  int continuous_audio_pwm_dma_init_IgnoreBool;
  CMOCK_continuous_audio_pwm_dma_init_CALLBACK continuous_audio_pwm_dma_init_CallbackFunctionPointer;
  int continuous_audio_pwm_dma_init_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE continuous_audio_pwm_dma_init_CallInstance;
  int set_volume_IgnoreBool;
  uint8_t set_volume_FinalReturn;
  CMOCK_set_volume_CALLBACK set_volume_CallbackFunctionPointer;
  int set_volume_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE set_volume_CallInstance;
  int set_lm48100q_volume_IgnoreBool;
  CMOCK_set_lm48100q_volume_CALLBACK set_lm48100q_volume_CallbackFunctionPointer;
  int set_lm48100q_volume_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE set_lm48100q_volume_CallInstance;
  int load_default_volume_IgnoreBool;
  CMOCK_load_default_volume_CALLBACK load_default_volume_CallbackFunctionPointer;
  int load_default_volume_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE load_default_volume_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void Mockaudio_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  if (Mock.audio_amp_init_IgnoreBool)
    Mock.audio_amp_init_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.audio_amp_init_CallInstance, cmock_line, "Function 'audio_amp_init' called less times than expected.");
  if (Mock.audio_amp_init_CallbackFunctionPointer != NULL)
    Mock.audio_amp_init_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.LM48100Q_I2C_StartTransmission_IgnoreBool)
    Mock.LM48100Q_I2C_StartTransmission_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.LM48100Q_I2C_StartTransmission_CallInstance, cmock_line, "Function 'LM48100Q_I2C_StartTransmission' called less times than expected.");
  if (Mock.LM48100Q_I2C_StartTransmission_CallbackFunctionPointer != NULL)
    Mock.LM48100Q_I2C_StartTransmission_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.audio_pwm_init_IgnoreBool)
    Mock.audio_pwm_init_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.audio_pwm_init_CallInstance, cmock_line, "Function 'audio_pwm_init' called less times than expected.");
  if (Mock.audio_pwm_init_CallbackFunctionPointer != NULL)
    Mock.audio_pwm_init_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.Audio_PWM_DMA_Init_IgnoreBool)
    Mock.Audio_PWM_DMA_Init_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.Audio_PWM_DMA_Init_CallInstance, cmock_line, "Function 'Audio_PWM_DMA_Init' called less times than expected.");
  if (Mock.Audio_PWM_DMA_Init_CallbackFunctionPointer != NULL)
    Mock.Audio_PWM_DMA_Init_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.poll_volume_ctrl_IgnoreBool)
    Mock.poll_volume_ctrl_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.poll_volume_ctrl_CallInstance, cmock_line, "Function 'poll_volume_ctrl' called less times than expected.");
  if (Mock.poll_volume_ctrl_CallbackFunctionPointer != NULL)
    Mock.poll_volume_ctrl_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.audio_vol_ctrl_init_IgnoreBool)
    Mock.audio_vol_ctrl_init_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.audio_vol_ctrl_init_CallInstance, cmock_line, "Function 'audio_vol_ctrl_init' called less times than expected.");
  if (Mock.audio_vol_ctrl_init_CallbackFunctionPointer != NULL)
    Mock.audio_vol_ctrl_init_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.audible_click_IgnoreBool)
    Mock.audible_click_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.audible_click_CallInstance, cmock_line, "Function 'audible_click' called less times than expected.");
  if (Mock.audible_click_CallbackFunctionPointer != NULL)
    Mock.audible_click_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.audio_alarmsound_IgnoreBool)
    Mock.audio_alarmsound_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.audio_alarmsound_CallInstance, cmock_line, "Function 'audio_alarmsound' called less times than expected.");
  if (Mock.audio_alarmsound_CallbackFunctionPointer != NULL)
    Mock.audio_alarmsound_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.reset_alarm_audio_IgnoreBool)
    Mock.reset_alarm_audio_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.reset_alarm_audio_CallInstance, cmock_line, "Function 'reset_alarm_audio' called less times than expected.");
  if (Mock.reset_alarm_audio_CallbackFunctionPointer != NULL)
    Mock.reset_alarm_audio_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.play_change_mode_audio_IgnoreBool)
    Mock.play_change_mode_audio_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.play_change_mode_audio_CallInstance, cmock_line, "Function 'play_change_mode_audio' called less times than expected.");
  if (Mock.play_change_mode_audio_CallbackFunctionPointer != NULL)
    Mock.play_change_mode_audio_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.continuous_audio_pwm_dma_init_IgnoreBool)
    Mock.continuous_audio_pwm_dma_init_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.continuous_audio_pwm_dma_init_CallInstance, cmock_line, "Function 'continuous_audio_pwm_dma_init' called less times than expected.");
  if (Mock.continuous_audio_pwm_dma_init_CallbackFunctionPointer != NULL)
    Mock.continuous_audio_pwm_dma_init_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.set_volume_IgnoreBool)
    Mock.set_volume_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.set_volume_CallInstance, cmock_line, "Function 'set_volume' called less times than expected.");
  if (Mock.set_volume_CallbackFunctionPointer != NULL)
    Mock.set_volume_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.set_lm48100q_volume_IgnoreBool)
    Mock.set_lm48100q_volume_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.set_lm48100q_volume_CallInstance, cmock_line, "Function 'set_lm48100q_volume' called less times than expected.");
  if (Mock.set_lm48100q_volume_CallbackFunctionPointer != NULL)
    Mock.set_lm48100q_volume_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.load_default_volume_IgnoreBool)
    Mock.load_default_volume_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.load_default_volume_CallInstance, cmock_line, "Function 'load_default_volume' called less times than expected.");
  if (Mock.load_default_volume_CallbackFunctionPointer != NULL)
    Mock.load_default_volume_CallInstance = CMOCK_GUTS_NONE;
}

void Mockaudio_Init(void)
{
  Mockaudio_Destroy();
}

void Mockaudio_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
  Mock.audio_amp_init_CallbackFunctionPointer = NULL;
  Mock.audio_amp_init_CallbackCalls = 0;
  Mock.LM48100Q_I2C_StartTransmission_CallbackFunctionPointer = NULL;
  Mock.LM48100Q_I2C_StartTransmission_CallbackCalls = 0;
  Mock.audio_pwm_init_CallbackFunctionPointer = NULL;
  Mock.audio_pwm_init_CallbackCalls = 0;
  Mock.Audio_PWM_DMA_Init_CallbackFunctionPointer = NULL;
  Mock.Audio_PWM_DMA_Init_CallbackCalls = 0;
  Mock.poll_volume_ctrl_CallbackFunctionPointer = NULL;
  Mock.poll_volume_ctrl_CallbackCalls = 0;
  Mock.audio_vol_ctrl_init_CallbackFunctionPointer = NULL;
  Mock.audio_vol_ctrl_init_CallbackCalls = 0;
  Mock.audible_click_CallbackFunctionPointer = NULL;
  Mock.audible_click_CallbackCalls = 0;
  Mock.audio_alarmsound_CallbackFunctionPointer = NULL;
  Mock.audio_alarmsound_CallbackCalls = 0;
  Mock.reset_alarm_audio_CallbackFunctionPointer = NULL;
  Mock.reset_alarm_audio_CallbackCalls = 0;
  Mock.play_change_mode_audio_CallbackFunctionPointer = NULL;
  Mock.play_change_mode_audio_CallbackCalls = 0;
  Mock.continuous_audio_pwm_dma_init_CallbackFunctionPointer = NULL;
  Mock.continuous_audio_pwm_dma_init_CallbackCalls = 0;
  Mock.set_volume_CallbackFunctionPointer = NULL;
  Mock.set_volume_CallbackCalls = 0;
  Mock.set_lm48100q_volume_CallbackFunctionPointer = NULL;
  Mock.set_lm48100q_volume_CallbackCalls = 0;
  Mock.load_default_volume_CallbackFunctionPointer = NULL;
  Mock.load_default_volume_CallbackCalls = 0;
}

uint8_t audio_amp_init(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_audio_amp_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_audio_amp_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.audio_amp_init_CallInstance);
  Mock.audio_amp_init_CallInstance = CMock_Guts_MemNext(Mock.audio_amp_init_CallInstance);
  if (Mock.audio_amp_init_CallbackFunctionPointer != NULL)
  {
    return Mock.audio_amp_init_CallbackFunctionPointer(Mock.audio_amp_init_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'audio_amp_init' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.audio_amp_init_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.audio_amp_init_FinalReturn;
    Mock.audio_amp_init_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void audio_amp_init_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_audio_amp_init_CALL_INSTANCE));
  CMOCK_audio_amp_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_audio_amp_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.audio_amp_init_CallInstance = CMock_Guts_MemChain(Mock.audio_amp_init_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.audio_amp_init_IgnoreBool = (int)1;
}

void audio_amp_init_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_audio_amp_init_CALL_INSTANCE));
  CMOCK_audio_amp_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_audio_amp_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.audio_amp_init_CallInstance = CMock_Guts_MemChain(Mock.audio_amp_init_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void audio_amp_init_StubWithCallback(CMOCK_audio_amp_init_CALLBACK Callback)
{
  Mock.audio_amp_init_CallbackFunctionPointer = Callback;
}

void LM48100Q_I2C_StartTransmission(uint8_t cmock_arg1)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_LM48100Q_I2C_StartTransmission_CALL_INSTANCE* cmock_call_instance = (CMOCK_LM48100Q_I2C_StartTransmission_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.LM48100Q_I2C_StartTransmission_CallInstance);
  Mock.LM48100Q_I2C_StartTransmission_CallInstance = CMock_Guts_MemNext(Mock.LM48100Q_I2C_StartTransmission_CallInstance);
  if (Mock.LM48100Q_I2C_StartTransmission_CallbackFunctionPointer != NULL)
  {
    Mock.LM48100Q_I2C_StartTransmission_CallbackFunctionPointer(cmock_arg1, Mock.LM48100Q_I2C_StartTransmission_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'LM48100Q_I2C_StartTransmission' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.LM48100Q_I2C_StartTransmission_IgnoreBool)
  {
    return;
  }
  UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_cmock_arg1, cmock_arg1, cmock_line, "Function 'LM48100Q_I2C_StartTransmission' called with unexpected value for argument 'cmock_arg1'.");
}

void CMockExpectParameters_LM48100Q_I2C_StartTransmission(CMOCK_LM48100Q_I2C_StartTransmission_CALL_INSTANCE* cmock_call_instance, uint8_t cmock_arg1)
{
  cmock_call_instance->Expected_cmock_arg1 = cmock_arg1;
}

void LM48100Q_I2C_StartTransmission_CMockIgnore(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_LM48100Q_I2C_StartTransmission_CALL_INSTANCE));
  CMOCK_LM48100Q_I2C_StartTransmission_CALL_INSTANCE* cmock_call_instance = (CMOCK_LM48100Q_I2C_StartTransmission_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.LM48100Q_I2C_StartTransmission_CallInstance = CMock_Guts_MemChain(Mock.LM48100Q_I2C_StartTransmission_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  Mock.LM48100Q_I2C_StartTransmission_IgnoreBool = (int)1;
}

void LM48100Q_I2C_StartTransmission_CMockExpect(UNITY_LINE_TYPE cmock_line, uint8_t cmock_arg1)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_LM48100Q_I2C_StartTransmission_CALL_INSTANCE));
  CMOCK_LM48100Q_I2C_StartTransmission_CALL_INSTANCE* cmock_call_instance = (CMOCK_LM48100Q_I2C_StartTransmission_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.LM48100Q_I2C_StartTransmission_CallInstance = CMock_Guts_MemChain(Mock.LM48100Q_I2C_StartTransmission_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_LM48100Q_I2C_StartTransmission(cmock_call_instance, cmock_arg1);
}

void LM48100Q_I2C_StartTransmission_StubWithCallback(CMOCK_LM48100Q_I2C_StartTransmission_CALLBACK Callback)
{
  Mock.LM48100Q_I2C_StartTransmission_CallbackFunctionPointer = Callback;
}

uint8_t audio_pwm_init(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_audio_pwm_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_audio_pwm_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.audio_pwm_init_CallInstance);
  Mock.audio_pwm_init_CallInstance = CMock_Guts_MemNext(Mock.audio_pwm_init_CallInstance);
  if (Mock.audio_pwm_init_CallbackFunctionPointer != NULL)
  {
    return Mock.audio_pwm_init_CallbackFunctionPointer(Mock.audio_pwm_init_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'audio_pwm_init' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.audio_pwm_init_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.audio_pwm_init_FinalReturn;
    Mock.audio_pwm_init_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void audio_pwm_init_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_audio_pwm_init_CALL_INSTANCE));
  CMOCK_audio_pwm_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_audio_pwm_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.audio_pwm_init_CallInstance = CMock_Guts_MemChain(Mock.audio_pwm_init_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.audio_pwm_init_IgnoreBool = (int)1;
}

void audio_pwm_init_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_audio_pwm_init_CALL_INSTANCE));
  CMOCK_audio_pwm_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_audio_pwm_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.audio_pwm_init_CallInstance = CMock_Guts_MemChain(Mock.audio_pwm_init_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void audio_pwm_init_StubWithCallback(CMOCK_audio_pwm_init_CALLBACK Callback)
{
  Mock.audio_pwm_init_CallbackFunctionPointer = Callback;
}

void Audio_PWM_DMA_Init(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_Audio_PWM_DMA_Init_CALL_INSTANCE* cmock_call_instance = (CMOCK_Audio_PWM_DMA_Init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.Audio_PWM_DMA_Init_CallInstance);
  Mock.Audio_PWM_DMA_Init_CallInstance = CMock_Guts_MemNext(Mock.Audio_PWM_DMA_Init_CallInstance);
  if (Mock.Audio_PWM_DMA_Init_CallbackFunctionPointer != NULL)
  {
    Mock.Audio_PWM_DMA_Init_CallbackFunctionPointer(Mock.Audio_PWM_DMA_Init_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'Audio_PWM_DMA_Init' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.Audio_PWM_DMA_Init_IgnoreBool)
  {
    return;
  }
}

void Audio_PWM_DMA_Init_CMockIgnore(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_Audio_PWM_DMA_Init_CALL_INSTANCE));
  CMOCK_Audio_PWM_DMA_Init_CALL_INSTANCE* cmock_call_instance = (CMOCK_Audio_PWM_DMA_Init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.Audio_PWM_DMA_Init_CallInstance = CMock_Guts_MemChain(Mock.Audio_PWM_DMA_Init_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  Mock.Audio_PWM_DMA_Init_IgnoreBool = (int)1;
}

void Audio_PWM_DMA_Init_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_Audio_PWM_DMA_Init_CALL_INSTANCE));
  CMOCK_Audio_PWM_DMA_Init_CALL_INSTANCE* cmock_call_instance = (CMOCK_Audio_PWM_DMA_Init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.Audio_PWM_DMA_Init_CallInstance = CMock_Guts_MemChain(Mock.Audio_PWM_DMA_Init_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
}

void Audio_PWM_DMA_Init_StubWithCallback(CMOCK_Audio_PWM_DMA_Init_CALLBACK Callback)
{
  Mock.Audio_PWM_DMA_Init_CallbackFunctionPointer = Callback;
}

uint8_t poll_volume_ctrl(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_poll_volume_ctrl_CALL_INSTANCE* cmock_call_instance = (CMOCK_poll_volume_ctrl_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.poll_volume_ctrl_CallInstance);
  Mock.poll_volume_ctrl_CallInstance = CMock_Guts_MemNext(Mock.poll_volume_ctrl_CallInstance);
  if (Mock.poll_volume_ctrl_CallbackFunctionPointer != NULL)
  {
    return Mock.poll_volume_ctrl_CallbackFunctionPointer(Mock.poll_volume_ctrl_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'poll_volume_ctrl' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.poll_volume_ctrl_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.poll_volume_ctrl_FinalReturn;
    Mock.poll_volume_ctrl_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void poll_volume_ctrl_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_poll_volume_ctrl_CALL_INSTANCE));
  CMOCK_poll_volume_ctrl_CALL_INSTANCE* cmock_call_instance = (CMOCK_poll_volume_ctrl_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.poll_volume_ctrl_CallInstance = CMock_Guts_MemChain(Mock.poll_volume_ctrl_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.poll_volume_ctrl_IgnoreBool = (int)1;
}

void poll_volume_ctrl_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_poll_volume_ctrl_CALL_INSTANCE));
  CMOCK_poll_volume_ctrl_CALL_INSTANCE* cmock_call_instance = (CMOCK_poll_volume_ctrl_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.poll_volume_ctrl_CallInstance = CMock_Guts_MemChain(Mock.poll_volume_ctrl_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void poll_volume_ctrl_StubWithCallback(CMOCK_poll_volume_ctrl_CALLBACK Callback)
{
  Mock.poll_volume_ctrl_CallbackFunctionPointer = Callback;
}

uint8_t audio_vol_ctrl_init(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_audio_vol_ctrl_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_audio_vol_ctrl_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.audio_vol_ctrl_init_CallInstance);
  Mock.audio_vol_ctrl_init_CallInstance = CMock_Guts_MemNext(Mock.audio_vol_ctrl_init_CallInstance);
  if (Mock.audio_vol_ctrl_init_CallbackFunctionPointer != NULL)
  {
    return Mock.audio_vol_ctrl_init_CallbackFunctionPointer(Mock.audio_vol_ctrl_init_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'audio_vol_ctrl_init' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.audio_vol_ctrl_init_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.audio_vol_ctrl_init_FinalReturn;
    Mock.audio_vol_ctrl_init_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void audio_vol_ctrl_init_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_audio_vol_ctrl_init_CALL_INSTANCE));
  CMOCK_audio_vol_ctrl_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_audio_vol_ctrl_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.audio_vol_ctrl_init_CallInstance = CMock_Guts_MemChain(Mock.audio_vol_ctrl_init_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.audio_vol_ctrl_init_IgnoreBool = (int)1;
}

void audio_vol_ctrl_init_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_audio_vol_ctrl_init_CALL_INSTANCE));
  CMOCK_audio_vol_ctrl_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_audio_vol_ctrl_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.audio_vol_ctrl_init_CallInstance = CMock_Guts_MemChain(Mock.audio_vol_ctrl_init_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void audio_vol_ctrl_init_StubWithCallback(CMOCK_audio_vol_ctrl_init_CALLBACK Callback)
{
  Mock.audio_vol_ctrl_init_CallbackFunctionPointer = Callback;
}

uint8_t audible_click(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_audible_click_CALL_INSTANCE* cmock_call_instance = (CMOCK_audible_click_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.audible_click_CallInstance);
  Mock.audible_click_CallInstance = CMock_Guts_MemNext(Mock.audible_click_CallInstance);
  if (Mock.audible_click_CallbackFunctionPointer != NULL)
  {
    return Mock.audible_click_CallbackFunctionPointer(Mock.audible_click_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'audible_click' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.audible_click_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.audible_click_FinalReturn;
    Mock.audible_click_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void audible_click_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_audible_click_CALL_INSTANCE));
  CMOCK_audible_click_CALL_INSTANCE* cmock_call_instance = (CMOCK_audible_click_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.audible_click_CallInstance = CMock_Guts_MemChain(Mock.audible_click_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.audible_click_IgnoreBool = (int)1;
}

void audible_click_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_audible_click_CALL_INSTANCE));
  CMOCK_audible_click_CALL_INSTANCE* cmock_call_instance = (CMOCK_audible_click_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.audible_click_CallInstance = CMock_Guts_MemChain(Mock.audible_click_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void audible_click_StubWithCallback(CMOCK_audible_click_CALLBACK Callback)
{
  Mock.audible_click_CallbackFunctionPointer = Callback;
}

void audio_alarmsound(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_audio_alarmsound_CALL_INSTANCE* cmock_call_instance = (CMOCK_audio_alarmsound_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.audio_alarmsound_CallInstance);
  Mock.audio_alarmsound_CallInstance = CMock_Guts_MemNext(Mock.audio_alarmsound_CallInstance);
  if (Mock.audio_alarmsound_CallbackFunctionPointer != NULL)
  {
    Mock.audio_alarmsound_CallbackFunctionPointer(Mock.audio_alarmsound_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'audio_alarmsound' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.audio_alarmsound_IgnoreBool)
  {
    return;
  }
}

void audio_alarmsound_CMockIgnore(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_audio_alarmsound_CALL_INSTANCE));
  CMOCK_audio_alarmsound_CALL_INSTANCE* cmock_call_instance = (CMOCK_audio_alarmsound_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.audio_alarmsound_CallInstance = CMock_Guts_MemChain(Mock.audio_alarmsound_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  Mock.audio_alarmsound_IgnoreBool = (int)1;
}

void audio_alarmsound_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_audio_alarmsound_CALL_INSTANCE));
  CMOCK_audio_alarmsound_CALL_INSTANCE* cmock_call_instance = (CMOCK_audio_alarmsound_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.audio_alarmsound_CallInstance = CMock_Guts_MemChain(Mock.audio_alarmsound_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
}

void audio_alarmsound_StubWithCallback(CMOCK_audio_alarmsound_CALLBACK Callback)
{
  Mock.audio_alarmsound_CallbackFunctionPointer = Callback;
}

uint8_t reset_alarm_audio(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_reset_alarm_audio_CALL_INSTANCE* cmock_call_instance = (CMOCK_reset_alarm_audio_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.reset_alarm_audio_CallInstance);
  Mock.reset_alarm_audio_CallInstance = CMock_Guts_MemNext(Mock.reset_alarm_audio_CallInstance);
  if (Mock.reset_alarm_audio_CallbackFunctionPointer != NULL)
  {
    return Mock.reset_alarm_audio_CallbackFunctionPointer(Mock.reset_alarm_audio_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'reset_alarm_audio' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.reset_alarm_audio_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.reset_alarm_audio_FinalReturn;
    Mock.reset_alarm_audio_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void reset_alarm_audio_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_reset_alarm_audio_CALL_INSTANCE));
  CMOCK_reset_alarm_audio_CALL_INSTANCE* cmock_call_instance = (CMOCK_reset_alarm_audio_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.reset_alarm_audio_CallInstance = CMock_Guts_MemChain(Mock.reset_alarm_audio_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.reset_alarm_audio_IgnoreBool = (int)1;
}

void reset_alarm_audio_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_reset_alarm_audio_CALL_INSTANCE));
  CMOCK_reset_alarm_audio_CALL_INSTANCE* cmock_call_instance = (CMOCK_reset_alarm_audio_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.reset_alarm_audio_CallInstance = CMock_Guts_MemChain(Mock.reset_alarm_audio_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void reset_alarm_audio_StubWithCallback(CMOCK_reset_alarm_audio_CALLBACK Callback)
{
  Mock.reset_alarm_audio_CallbackFunctionPointer = Callback;
}

uint8_t play_change_mode_audio(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_play_change_mode_audio_CALL_INSTANCE* cmock_call_instance = (CMOCK_play_change_mode_audio_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.play_change_mode_audio_CallInstance);
  Mock.play_change_mode_audio_CallInstance = CMock_Guts_MemNext(Mock.play_change_mode_audio_CallInstance);
  if (Mock.play_change_mode_audio_CallbackFunctionPointer != NULL)
  {
    return Mock.play_change_mode_audio_CallbackFunctionPointer(Mock.play_change_mode_audio_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'play_change_mode_audio' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.play_change_mode_audio_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.play_change_mode_audio_FinalReturn;
    Mock.play_change_mode_audio_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void play_change_mode_audio_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_play_change_mode_audio_CALL_INSTANCE));
  CMOCK_play_change_mode_audio_CALL_INSTANCE* cmock_call_instance = (CMOCK_play_change_mode_audio_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.play_change_mode_audio_CallInstance = CMock_Guts_MemChain(Mock.play_change_mode_audio_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.play_change_mode_audio_IgnoreBool = (int)1;
}

void play_change_mode_audio_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_play_change_mode_audio_CALL_INSTANCE));
  CMOCK_play_change_mode_audio_CALL_INSTANCE* cmock_call_instance = (CMOCK_play_change_mode_audio_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.play_change_mode_audio_CallInstance = CMock_Guts_MemChain(Mock.play_change_mode_audio_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void play_change_mode_audio_StubWithCallback(CMOCK_play_change_mode_audio_CALLBACK Callback)
{
  Mock.play_change_mode_audio_CallbackFunctionPointer = Callback;
}

void continuous_audio_pwm_dma_init(uint16_t cmock_arg1)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_continuous_audio_pwm_dma_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_continuous_audio_pwm_dma_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.continuous_audio_pwm_dma_init_CallInstance);
  Mock.continuous_audio_pwm_dma_init_CallInstance = CMock_Guts_MemNext(Mock.continuous_audio_pwm_dma_init_CallInstance);
  if (Mock.continuous_audio_pwm_dma_init_CallbackFunctionPointer != NULL)
  {
    Mock.continuous_audio_pwm_dma_init_CallbackFunctionPointer(cmock_arg1, Mock.continuous_audio_pwm_dma_init_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'continuous_audio_pwm_dma_init' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.continuous_audio_pwm_dma_init_IgnoreBool)
  {
    return;
  }
  UNITY_TEST_ASSERT_EQUAL_HEX16(cmock_call_instance->Expected_cmock_arg1, cmock_arg1, cmock_line, "Function 'continuous_audio_pwm_dma_init' called with unexpected value for argument 'cmock_arg1'.");
}

void CMockExpectParameters_continuous_audio_pwm_dma_init(CMOCK_continuous_audio_pwm_dma_init_CALL_INSTANCE* cmock_call_instance, uint16_t cmock_arg1)
{
  cmock_call_instance->Expected_cmock_arg1 = cmock_arg1;
}

void continuous_audio_pwm_dma_init_CMockIgnore(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_continuous_audio_pwm_dma_init_CALL_INSTANCE));
  CMOCK_continuous_audio_pwm_dma_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_continuous_audio_pwm_dma_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.continuous_audio_pwm_dma_init_CallInstance = CMock_Guts_MemChain(Mock.continuous_audio_pwm_dma_init_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  Mock.continuous_audio_pwm_dma_init_IgnoreBool = (int)1;
}

void continuous_audio_pwm_dma_init_CMockExpect(UNITY_LINE_TYPE cmock_line, uint16_t cmock_arg1)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_continuous_audio_pwm_dma_init_CALL_INSTANCE));
  CMOCK_continuous_audio_pwm_dma_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_continuous_audio_pwm_dma_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.continuous_audio_pwm_dma_init_CallInstance = CMock_Guts_MemChain(Mock.continuous_audio_pwm_dma_init_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_continuous_audio_pwm_dma_init(cmock_call_instance, cmock_arg1);
}

void continuous_audio_pwm_dma_init_StubWithCallback(CMOCK_continuous_audio_pwm_dma_init_CALLBACK Callback)
{
  Mock.continuous_audio_pwm_dma_init_CallbackFunctionPointer = Callback;
}

uint8_t set_volume(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_set_volume_CALL_INSTANCE* cmock_call_instance = (CMOCK_set_volume_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.set_volume_CallInstance);
  Mock.set_volume_CallInstance = CMock_Guts_MemNext(Mock.set_volume_CallInstance);
  if (Mock.set_volume_CallbackFunctionPointer != NULL)
  {
    return Mock.set_volume_CallbackFunctionPointer(Mock.set_volume_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'set_volume' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.set_volume_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.set_volume_FinalReturn;
    Mock.set_volume_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void set_volume_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_set_volume_CALL_INSTANCE));
  CMOCK_set_volume_CALL_INSTANCE* cmock_call_instance = (CMOCK_set_volume_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.set_volume_CallInstance = CMock_Guts_MemChain(Mock.set_volume_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.set_volume_IgnoreBool = (int)1;
}

void set_volume_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_set_volume_CALL_INSTANCE));
  CMOCK_set_volume_CALL_INSTANCE* cmock_call_instance = (CMOCK_set_volume_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.set_volume_CallInstance = CMock_Guts_MemChain(Mock.set_volume_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void set_volume_StubWithCallback(CMOCK_set_volume_CALLBACK Callback)
{
  Mock.set_volume_CallbackFunctionPointer = Callback;
}

void set_lm48100q_volume(uint8_t cmock_arg1)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_set_lm48100q_volume_CALL_INSTANCE* cmock_call_instance = (CMOCK_set_lm48100q_volume_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.set_lm48100q_volume_CallInstance);
  Mock.set_lm48100q_volume_CallInstance = CMock_Guts_MemNext(Mock.set_lm48100q_volume_CallInstance);
  if (Mock.set_lm48100q_volume_CallbackFunctionPointer != NULL)
  {
    Mock.set_lm48100q_volume_CallbackFunctionPointer(cmock_arg1, Mock.set_lm48100q_volume_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'set_lm48100q_volume' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.set_lm48100q_volume_IgnoreBool)
  {
    return;
  }
  UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_cmock_arg1, cmock_arg1, cmock_line, "Function 'set_lm48100q_volume' called with unexpected value for argument 'cmock_arg1'.");
}

void CMockExpectParameters_set_lm48100q_volume(CMOCK_set_lm48100q_volume_CALL_INSTANCE* cmock_call_instance, uint8_t cmock_arg1)
{
  cmock_call_instance->Expected_cmock_arg1 = cmock_arg1;
}

void set_lm48100q_volume_CMockIgnore(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_set_lm48100q_volume_CALL_INSTANCE));
  CMOCK_set_lm48100q_volume_CALL_INSTANCE* cmock_call_instance = (CMOCK_set_lm48100q_volume_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.set_lm48100q_volume_CallInstance = CMock_Guts_MemChain(Mock.set_lm48100q_volume_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  Mock.set_lm48100q_volume_IgnoreBool = (int)1;
}

void set_lm48100q_volume_CMockExpect(UNITY_LINE_TYPE cmock_line, uint8_t cmock_arg1)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_set_lm48100q_volume_CALL_INSTANCE));
  CMOCK_set_lm48100q_volume_CALL_INSTANCE* cmock_call_instance = (CMOCK_set_lm48100q_volume_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.set_lm48100q_volume_CallInstance = CMock_Guts_MemChain(Mock.set_lm48100q_volume_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_set_lm48100q_volume(cmock_call_instance, cmock_arg1);
}

void set_lm48100q_volume_StubWithCallback(CMOCK_set_lm48100q_volume_CALLBACK Callback)
{
  Mock.set_lm48100q_volume_CallbackFunctionPointer = Callback;
}

void load_default_volume(uint8_t cmock_arg1, uint8_t cmock_arg2)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_load_default_volume_CALL_INSTANCE* cmock_call_instance = (CMOCK_load_default_volume_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.load_default_volume_CallInstance);
  Mock.load_default_volume_CallInstance = CMock_Guts_MemNext(Mock.load_default_volume_CallInstance);
  if (Mock.load_default_volume_CallbackFunctionPointer != NULL)
  {
    Mock.load_default_volume_CallbackFunctionPointer(cmock_arg1, cmock_arg2, Mock.load_default_volume_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'load_default_volume' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.load_default_volume_IgnoreBool)
  {
    return;
  }
  UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_cmock_arg1, cmock_arg1, cmock_line, "Function 'load_default_volume' called with unexpected value for argument 'cmock_arg1'.");
  UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_cmock_arg2, cmock_arg2, cmock_line, "Function 'load_default_volume' called with unexpected value for argument 'cmock_arg2'.");
}

void CMockExpectParameters_load_default_volume(CMOCK_load_default_volume_CALL_INSTANCE* cmock_call_instance, uint8_t cmock_arg1, uint8_t cmock_arg2)
{
  cmock_call_instance->Expected_cmock_arg1 = cmock_arg1;
  cmock_call_instance->Expected_cmock_arg2 = cmock_arg2;
}

void load_default_volume_CMockIgnore(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_load_default_volume_CALL_INSTANCE));
  CMOCK_load_default_volume_CALL_INSTANCE* cmock_call_instance = (CMOCK_load_default_volume_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.load_default_volume_CallInstance = CMock_Guts_MemChain(Mock.load_default_volume_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  Mock.load_default_volume_IgnoreBool = (int)1;
}

void load_default_volume_CMockExpect(UNITY_LINE_TYPE cmock_line, uint8_t cmock_arg1, uint8_t cmock_arg2)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_load_default_volume_CALL_INSTANCE));
  CMOCK_load_default_volume_CALL_INSTANCE* cmock_call_instance = (CMOCK_load_default_volume_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.load_default_volume_CallInstance = CMock_Guts_MemChain(Mock.load_default_volume_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_load_default_volume(cmock_call_instance, cmock_arg1, cmock_arg2);
}

void load_default_volume_StubWithCallback(CMOCK_load_default_volume_CALLBACK Callback)
{
  Mock.load_default_volume_CallbackFunctionPointer = Callback;
}

