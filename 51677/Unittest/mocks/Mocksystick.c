/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "unity.h"
#include "cmock.h"
#include "Mocksystick.h"

typedef struct _CMOCK_systick_init_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  u8 ReturnVal;

} CMOCK_systick_init_CALL_INSTANCE;

typedef struct _CMOCK_cbtmr_isr_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  u8 ReturnVal;

} CMOCK_cbtmr_isr_CALL_INSTANCE;

typedef struct _CMOCK_cbtmr_reg_callback_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  ErrorStatus ReturnVal;
  cbtmr_func_t Expected_cbtmr_func;
  FlagStatus* Expected_cbtmr_flag;
  u32 Expected_cbtmr_time_ms;
  cbtmr_mode_t Expected_cbtmr_mode;
  u8* Expected_cbtmr_id;

} CMOCK_cbtmr_reg_callback_CALL_INSTANCE;

typedef struct _CMOCK_cbtmr_unreg_callback_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  ErrorStatus ReturnVal;
  u8 Expected_UnregID;

} CMOCK_cbtmr_unreg_callback_CALL_INSTANCE;

static struct MocksystickInstance
{
  int systick_init_IgnoreBool;
  u8 systick_init_FinalReturn;
  CMOCK_systick_init_CALLBACK systick_init_CallbackFunctionPointer;
  int systick_init_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE systick_init_CallInstance;
  int cbtmr_isr_IgnoreBool;
  u8 cbtmr_isr_FinalReturn;
  CMOCK_cbtmr_isr_CALLBACK cbtmr_isr_CallbackFunctionPointer;
  int cbtmr_isr_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE cbtmr_isr_CallInstance;
  int cbtmr_reg_callback_IgnoreBool;
  ErrorStatus cbtmr_reg_callback_FinalReturn;
  CMOCK_cbtmr_reg_callback_CALLBACK cbtmr_reg_callback_CallbackFunctionPointer;
  int cbtmr_reg_callback_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE cbtmr_reg_callback_CallInstance;
  int cbtmr_unreg_callback_IgnoreBool;
  ErrorStatus cbtmr_unreg_callback_FinalReturn;
  CMOCK_cbtmr_unreg_callback_CALLBACK cbtmr_unreg_callback_CallbackFunctionPointer;
  int cbtmr_unreg_callback_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE cbtmr_unreg_callback_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void Mocksystick_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  if (Mock.systick_init_IgnoreBool)
    Mock.systick_init_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.systick_init_CallInstance, cmock_line, "Function 'systick_init' called less times than expected.");
  if (Mock.systick_init_CallbackFunctionPointer != NULL)
    Mock.systick_init_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.cbtmr_isr_IgnoreBool)
    Mock.cbtmr_isr_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.cbtmr_isr_CallInstance, cmock_line, "Function 'cbtmr_isr' called less times than expected.");
  if (Mock.cbtmr_isr_CallbackFunctionPointer != NULL)
    Mock.cbtmr_isr_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.cbtmr_reg_callback_IgnoreBool)
    Mock.cbtmr_reg_callback_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.cbtmr_reg_callback_CallInstance, cmock_line, "Function 'cbtmr_reg_callback' called less times than expected.");
  if (Mock.cbtmr_reg_callback_CallbackFunctionPointer != NULL)
    Mock.cbtmr_reg_callback_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.cbtmr_unreg_callback_IgnoreBool)
    Mock.cbtmr_unreg_callback_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.cbtmr_unreg_callback_CallInstance, cmock_line, "Function 'cbtmr_unreg_callback' called less times than expected.");
  if (Mock.cbtmr_unreg_callback_CallbackFunctionPointer != NULL)
    Mock.cbtmr_unreg_callback_CallInstance = CMOCK_GUTS_NONE;
}

void Mocksystick_Init(void)
{
  Mocksystick_Destroy();
}

void Mocksystick_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
  Mock.systick_init_CallbackFunctionPointer = NULL;
  Mock.systick_init_CallbackCalls = 0;
  Mock.cbtmr_isr_CallbackFunctionPointer = NULL;
  Mock.cbtmr_isr_CallbackCalls = 0;
  Mock.cbtmr_reg_callback_CallbackFunctionPointer = NULL;
  Mock.cbtmr_reg_callback_CallbackCalls = 0;
  Mock.cbtmr_unreg_callback_CallbackFunctionPointer = NULL;
  Mock.cbtmr_unreg_callback_CallbackCalls = 0;
}

u8 systick_init(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_systick_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_systick_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.systick_init_CallInstance);
  Mock.systick_init_CallInstance = CMock_Guts_MemNext(Mock.systick_init_CallInstance);
  if (Mock.systick_init_CallbackFunctionPointer != NULL)
  {
    return Mock.systick_init_CallbackFunctionPointer(Mock.systick_init_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'systick_init' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.systick_init_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.systick_init_FinalReturn;
    memcpy(&Mock.systick_init_FinalReturn, &cmock_call_instance->ReturnVal, sizeof(u8));
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void systick_init_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, u8 cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_systick_init_CALL_INSTANCE));
  CMOCK_systick_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_systick_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.systick_init_CallInstance = CMock_Guts_MemChain(Mock.systick_init_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.systick_init_IgnoreBool = (int)1;
}

void systick_init_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, u8 cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_systick_init_CALL_INSTANCE));
  CMOCK_systick_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_systick_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.systick_init_CallInstance = CMock_Guts_MemChain(Mock.systick_init_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy(&cmock_call_instance->ReturnVal, &cmock_to_return, sizeof(u8));
}

void systick_init_StubWithCallback(CMOCK_systick_init_CALLBACK Callback)
{
  Mock.systick_init_CallbackFunctionPointer = Callback;
}

u8 cbtmr_isr(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_cbtmr_isr_CALL_INSTANCE* cmock_call_instance = (CMOCK_cbtmr_isr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.cbtmr_isr_CallInstance);
  Mock.cbtmr_isr_CallInstance = CMock_Guts_MemNext(Mock.cbtmr_isr_CallInstance);
  if (Mock.cbtmr_isr_CallbackFunctionPointer != NULL)
  {
    return Mock.cbtmr_isr_CallbackFunctionPointer(Mock.cbtmr_isr_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'cbtmr_isr' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.cbtmr_isr_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.cbtmr_isr_FinalReturn;
    memcpy(&Mock.cbtmr_isr_FinalReturn, &cmock_call_instance->ReturnVal, sizeof(u8));
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void cbtmr_isr_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, u8 cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_cbtmr_isr_CALL_INSTANCE));
  CMOCK_cbtmr_isr_CALL_INSTANCE* cmock_call_instance = (CMOCK_cbtmr_isr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.cbtmr_isr_CallInstance = CMock_Guts_MemChain(Mock.cbtmr_isr_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.cbtmr_isr_IgnoreBool = (int)1;
}

void cbtmr_isr_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, u8 cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_cbtmr_isr_CALL_INSTANCE));
  CMOCK_cbtmr_isr_CALL_INSTANCE* cmock_call_instance = (CMOCK_cbtmr_isr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.cbtmr_isr_CallInstance = CMock_Guts_MemChain(Mock.cbtmr_isr_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy(&cmock_call_instance->ReturnVal, &cmock_to_return, sizeof(u8));
}

void cbtmr_isr_StubWithCallback(CMOCK_cbtmr_isr_CALLBACK Callback)
{
  Mock.cbtmr_isr_CallbackFunctionPointer = Callback;
}

ErrorStatus cbtmr_reg_callback(cbtmr_func_t cbtmr_func, FlagStatus* cbtmr_flag, u32 cbtmr_time_ms, cbtmr_mode_t cbtmr_mode, u8* cbtmr_id)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_cbtmr_reg_callback_CALL_INSTANCE* cmock_call_instance = (CMOCK_cbtmr_reg_callback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.cbtmr_reg_callback_CallInstance);
  Mock.cbtmr_reg_callback_CallInstance = CMock_Guts_MemNext(Mock.cbtmr_reg_callback_CallInstance);
  if (Mock.cbtmr_reg_callback_CallbackFunctionPointer != NULL)
  {
    return Mock.cbtmr_reg_callback_CallbackFunctionPointer(cbtmr_func, cbtmr_flag, cbtmr_time_ms, cbtmr_mode, cbtmr_id, Mock.cbtmr_reg_callback_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'cbtmr_reg_callback' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.cbtmr_reg_callback_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.cbtmr_reg_callback_FinalReturn;
    memcpy(&Mock.cbtmr_reg_callback_FinalReturn, &cmock_call_instance->ReturnVal, sizeof(ErrorStatus));
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_cbtmr_func), (void*)(&cbtmr_func), sizeof(cbtmr_func_t), cmock_line, "Function 'cbtmr_reg_callback' called with unexpected value for argument 'cbtmr_func'.");
  UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_cbtmr_flag), (void*)(cbtmr_flag), sizeof(FlagStatus), cmock_line, "Function 'cbtmr_reg_callback' called with unexpected value for argument 'cbtmr_flag'.");
  UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_cbtmr_time_ms), (void*)(&cbtmr_time_ms), sizeof(u32), cmock_line, "Function 'cbtmr_reg_callback' called with unexpected value for argument 'cbtmr_time_ms'.");
  UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_cbtmr_mode), (void*)(&cbtmr_mode), sizeof(cbtmr_mode_t), cmock_line, "Function 'cbtmr_reg_callback' called with unexpected value for argument 'cbtmr_mode'.");
  UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_cbtmr_id), (void*)(cbtmr_id), sizeof(u8), cmock_line, "Function 'cbtmr_reg_callback' called with unexpected value for argument 'cbtmr_id'.");
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_cbtmr_reg_callback(CMOCK_cbtmr_reg_callback_CALL_INSTANCE* cmock_call_instance, cbtmr_func_t cbtmr_func, FlagStatus* cbtmr_flag, u32 cbtmr_time_ms, cbtmr_mode_t cbtmr_mode, u8* cbtmr_id)
{
  memcpy(&cmock_call_instance->Expected_cbtmr_func, &cbtmr_func, sizeof(cbtmr_func_t));
  cmock_call_instance->Expected_cbtmr_flag = cbtmr_flag;
  memcpy(&cmock_call_instance->Expected_cbtmr_time_ms, &cbtmr_time_ms, sizeof(u32));
  memcpy(&cmock_call_instance->Expected_cbtmr_mode, &cbtmr_mode, sizeof(cbtmr_mode_t));
  cmock_call_instance->Expected_cbtmr_id = cbtmr_id;
}

void cbtmr_reg_callback_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, ErrorStatus cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_cbtmr_reg_callback_CALL_INSTANCE));
  CMOCK_cbtmr_reg_callback_CALL_INSTANCE* cmock_call_instance = (CMOCK_cbtmr_reg_callback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.cbtmr_reg_callback_CallInstance = CMock_Guts_MemChain(Mock.cbtmr_reg_callback_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.cbtmr_reg_callback_IgnoreBool = (int)1;
}

void cbtmr_reg_callback_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, cbtmr_func_t cbtmr_func, FlagStatus* cbtmr_flag, u32 cbtmr_time_ms, cbtmr_mode_t cbtmr_mode, u8* cbtmr_id, ErrorStatus cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_cbtmr_reg_callback_CALL_INSTANCE));
  CMOCK_cbtmr_reg_callback_CALL_INSTANCE* cmock_call_instance = (CMOCK_cbtmr_reg_callback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.cbtmr_reg_callback_CallInstance = CMock_Guts_MemChain(Mock.cbtmr_reg_callback_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_cbtmr_reg_callback(cmock_call_instance, cbtmr_func, cbtmr_flag, cbtmr_time_ms, cbtmr_mode, cbtmr_id);
  memcpy(&cmock_call_instance->ReturnVal, &cmock_to_return, sizeof(ErrorStatus));
}

void cbtmr_reg_callback_StubWithCallback(CMOCK_cbtmr_reg_callback_CALLBACK Callback)
{
  Mock.cbtmr_reg_callback_CallbackFunctionPointer = Callback;
}

ErrorStatus cbtmr_unreg_callback(u8 UnregID)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_cbtmr_unreg_callback_CALL_INSTANCE* cmock_call_instance = (CMOCK_cbtmr_unreg_callback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.cbtmr_unreg_callback_CallInstance);
  Mock.cbtmr_unreg_callback_CallInstance = CMock_Guts_MemNext(Mock.cbtmr_unreg_callback_CallInstance);
  if (Mock.cbtmr_unreg_callback_CallbackFunctionPointer != NULL)
  {
    return Mock.cbtmr_unreg_callback_CallbackFunctionPointer(UnregID, Mock.cbtmr_unreg_callback_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'cbtmr_unreg_callback' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.cbtmr_unreg_callback_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.cbtmr_unreg_callback_FinalReturn;
    memcpy(&Mock.cbtmr_unreg_callback_FinalReturn, &cmock_call_instance->ReturnVal, sizeof(ErrorStatus));
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_UnregID), (void*)(&UnregID), sizeof(u8), cmock_line, "Function 'cbtmr_unreg_callback' called with unexpected value for argument 'UnregID'.");
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_cbtmr_unreg_callback(CMOCK_cbtmr_unreg_callback_CALL_INSTANCE* cmock_call_instance, u8 UnregID)
{
  memcpy(&cmock_call_instance->Expected_UnregID, &UnregID, sizeof(u8));
}

void cbtmr_unreg_callback_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, ErrorStatus cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_cbtmr_unreg_callback_CALL_INSTANCE));
  CMOCK_cbtmr_unreg_callback_CALL_INSTANCE* cmock_call_instance = (CMOCK_cbtmr_unreg_callback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.cbtmr_unreg_callback_CallInstance = CMock_Guts_MemChain(Mock.cbtmr_unreg_callback_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.cbtmr_unreg_callback_IgnoreBool = (int)1;
}

void cbtmr_unreg_callback_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, u8 UnregID, ErrorStatus cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_cbtmr_unreg_callback_CALL_INSTANCE));
  CMOCK_cbtmr_unreg_callback_CALL_INSTANCE* cmock_call_instance = (CMOCK_cbtmr_unreg_callback_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.cbtmr_unreg_callback_CallInstance = CMock_Guts_MemChain(Mock.cbtmr_unreg_callback_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_cbtmr_unreg_callback(cmock_call_instance, UnregID);
  memcpy(&cmock_call_instance->ReturnVal, &cmock_to_return, sizeof(ErrorStatus));
}

void cbtmr_unreg_callback_StubWithCallback(CMOCK_cbtmr_unreg_callback_CALLBACK Callback)
{
  Mock.cbtmr_unreg_callback_CallbackFunctionPointer = Callback;
}

