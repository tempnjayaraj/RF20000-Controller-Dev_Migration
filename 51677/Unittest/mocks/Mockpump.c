/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "unity.h"
#include "cmock.h"
#include "Mockpump.h"

typedef struct _CMOCK_PumpPID_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  float32_t ReturnVal;
  q15_t Expected_pv;
  bool Expected_cmock_arg1;

} CMOCK_PumpPID_CALL_INSTANCE;

typedef struct _CMOCK_pump_inactivity_monitor_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_pump_inactivity_monitor_CALL_INSTANCE;

typedef struct _CMOCK_pump_speed_ctrl_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_pump_speed_ctrl_CALL_INSTANCE;

typedef struct _CMOCK_PumpFIR_Init_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  q15_t Expected_cmock_arg1;

} CMOCK_PumpFIR_Init_CALL_INSTANCE;

typedef struct _CMOCK_PumpUART4_Init_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BAUD_RATE Expected_cmock_arg1;

} CMOCK_PumpUART4_Init_CALL_INSTANCE;

typedef struct _CMOCK_send_pump_cmd_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;

} CMOCK_send_pump_cmd_CALL_INSTANCE;

typedef struct _CMOCK_receive_pump_cmd_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_receive_pump_cmd_CALL_INSTANCE;

typedef struct _CMOCK_pump_packetizer_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_pump_packetizer_CALL_INSTANCE;

typedef struct _CMOCK_pump_reset_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_pump_reset_CALL_INSTANCE;

typedef struct _CMOCK_pump_cmd_ack_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_pump_cmd_ack_CALL_INSTANCE;

typedef struct _CMOCK_drive_status_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_drive_status_CALL_INSTANCE;

typedef struct _CMOCK_pump_cmd_nack_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_pump_cmd_nack_CALL_INSTANCE;

typedef struct _CMOCK_drive_power_mode_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_drive_power_mode_CALL_INSTANCE;

typedef struct _CMOCK_probe_test_complete_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_probe_test_complete_CALL_INSTANCE;

typedef struct _CMOCK_over_current_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_over_current_CALL_INSTANCE;

typedef struct _CMOCK_over_energy_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_over_energy_CALL_INSTANCE;

typedef struct _CMOCK_pump_uart_init_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_pump_uart_init_CALL_INSTANCE;

typedef struct _CMOCK_pump_cmd_eack_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_pump_cmd_eack_CALL_INSTANCE;

typedef struct _CMOCK_pump_startup_delay_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_pump_startup_delay_CALL_INSTANCE;

typedef struct _CMOCK_pump_set_speed_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  float Expected_Speed;

} CMOCK_pump_set_speed_CALL_INSTANCE;

static struct MockpumpInstance
{
  int PumpPID_IgnoreBool;
  float32_t PumpPID_FinalReturn;
  CMOCK_PumpPID_CALLBACK PumpPID_CallbackFunctionPointer;
  int PumpPID_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE PumpPID_CallInstance;
  int pump_inactivity_monitor_IgnoreBool;
  uint8_t pump_inactivity_monitor_FinalReturn;
  CMOCK_pump_inactivity_monitor_CALLBACK pump_inactivity_monitor_CallbackFunctionPointer;
  int pump_inactivity_monitor_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE pump_inactivity_monitor_CallInstance;
  int pump_speed_ctrl_IgnoreBool;
  uint8_t pump_speed_ctrl_FinalReturn;
  CMOCK_pump_speed_ctrl_CALLBACK pump_speed_ctrl_CallbackFunctionPointer;
  int pump_speed_ctrl_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE pump_speed_ctrl_CallInstance;
  int PumpFIR_Init_IgnoreBool;
  CMOCK_PumpFIR_Init_CALLBACK PumpFIR_Init_CallbackFunctionPointer;
  int PumpFIR_Init_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE PumpFIR_Init_CallInstance;
  int PumpUART4_Init_IgnoreBool;
  CMOCK_PumpUART4_Init_CALLBACK PumpUART4_Init_CallbackFunctionPointer;
  int PumpUART4_Init_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE PumpUART4_Init_CallInstance;
  int send_pump_cmd_IgnoreBool;
  CMOCK_send_pump_cmd_CALLBACK send_pump_cmd_CallbackFunctionPointer;
  int send_pump_cmd_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE send_pump_cmd_CallInstance;
  int receive_pump_cmd_IgnoreBool;
  uint8_t receive_pump_cmd_FinalReturn;
  CMOCK_receive_pump_cmd_CALLBACK receive_pump_cmd_CallbackFunctionPointer;
  int receive_pump_cmd_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE receive_pump_cmd_CallInstance;
  int pump_packetizer_IgnoreBool;
  uint8_t pump_packetizer_FinalReturn;
  CMOCK_pump_packetizer_CALLBACK pump_packetizer_CallbackFunctionPointer;
  int pump_packetizer_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE pump_packetizer_CallInstance;
  int pump_reset_IgnoreBool;
  uint8_t pump_reset_FinalReturn;
  CMOCK_pump_reset_CALLBACK pump_reset_CallbackFunctionPointer;
  int pump_reset_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE pump_reset_CallInstance;
  int pump_cmd_ack_IgnoreBool;
  uint8_t pump_cmd_ack_FinalReturn;
  CMOCK_pump_cmd_ack_CALLBACK pump_cmd_ack_CallbackFunctionPointer;
  int pump_cmd_ack_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE pump_cmd_ack_CallInstance;
  int drive_status_IgnoreBool;
  uint8_t drive_status_FinalReturn;
  CMOCK_drive_status_CALLBACK drive_status_CallbackFunctionPointer;
  int drive_status_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE drive_status_CallInstance;
  int pump_cmd_nack_IgnoreBool;
  uint8_t pump_cmd_nack_FinalReturn;
  CMOCK_pump_cmd_nack_CALLBACK pump_cmd_nack_CallbackFunctionPointer;
  int pump_cmd_nack_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE pump_cmd_nack_CallInstance;
  int drive_power_mode_IgnoreBool;
  uint8_t drive_power_mode_FinalReturn;
  CMOCK_drive_power_mode_CALLBACK drive_power_mode_CallbackFunctionPointer;
  int drive_power_mode_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE drive_power_mode_CallInstance;
  int probe_test_complete_IgnoreBool;
  uint8_t probe_test_complete_FinalReturn;
  CMOCK_probe_test_complete_CALLBACK probe_test_complete_CallbackFunctionPointer;
  int probe_test_complete_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE probe_test_complete_CallInstance;
  int over_current_IgnoreBool;
  uint8_t over_current_FinalReturn;
  CMOCK_over_current_CALLBACK over_current_CallbackFunctionPointer;
  int over_current_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE over_current_CallInstance;
  int over_energy_IgnoreBool;
  uint8_t over_energy_FinalReturn;
  CMOCK_over_energy_CALLBACK over_energy_CallbackFunctionPointer;
  int over_energy_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE over_energy_CallInstance;
  int pump_uart_init_IgnoreBool;
  uint8_t pump_uart_init_FinalReturn;
  CMOCK_pump_uart_init_CALLBACK pump_uart_init_CallbackFunctionPointer;
  int pump_uart_init_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE pump_uart_init_CallInstance;
  int pump_cmd_eack_IgnoreBool;
  uint8_t pump_cmd_eack_FinalReturn;
  CMOCK_pump_cmd_eack_CALLBACK pump_cmd_eack_CallbackFunctionPointer;
  int pump_cmd_eack_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE pump_cmd_eack_CallInstance;
  int pump_startup_delay_IgnoreBool;
  uint8_t pump_startup_delay_FinalReturn;
  CMOCK_pump_startup_delay_CALLBACK pump_startup_delay_CallbackFunctionPointer;
  int pump_startup_delay_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE pump_startup_delay_CallInstance;
  int pump_set_speed_IgnoreBool;
  CMOCK_pump_set_speed_CALLBACK pump_set_speed_CallbackFunctionPointer;
  int pump_set_speed_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE pump_set_speed_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void Mockpump_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  if (Mock.PumpPID_IgnoreBool)
    Mock.PumpPID_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.PumpPID_CallInstance, cmock_line, "Function 'PumpPID' called less times than expected.");
  if (Mock.PumpPID_CallbackFunctionPointer != NULL)
    Mock.PumpPID_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.pump_inactivity_monitor_IgnoreBool)
    Mock.pump_inactivity_monitor_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.pump_inactivity_monitor_CallInstance, cmock_line, "Function 'pump_inactivity_monitor' called less times than expected.");
  if (Mock.pump_inactivity_monitor_CallbackFunctionPointer != NULL)
    Mock.pump_inactivity_monitor_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.pump_speed_ctrl_IgnoreBool)
    Mock.pump_speed_ctrl_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.pump_speed_ctrl_CallInstance, cmock_line, "Function 'pump_speed_ctrl' called less times than expected.");
  if (Mock.pump_speed_ctrl_CallbackFunctionPointer != NULL)
    Mock.pump_speed_ctrl_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.PumpFIR_Init_IgnoreBool)
    Mock.PumpFIR_Init_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.PumpFIR_Init_CallInstance, cmock_line, "Function 'PumpFIR_Init' called less times than expected.");
  if (Mock.PumpFIR_Init_CallbackFunctionPointer != NULL)
    Mock.PumpFIR_Init_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.PumpUART4_Init_IgnoreBool)
    Mock.PumpUART4_Init_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.PumpUART4_Init_CallInstance, cmock_line, "Function 'PumpUART4_Init' called less times than expected.");
  if (Mock.PumpUART4_Init_CallbackFunctionPointer != NULL)
    Mock.PumpUART4_Init_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.send_pump_cmd_IgnoreBool)
    Mock.send_pump_cmd_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.send_pump_cmd_CallInstance, cmock_line, "Function 'send_pump_cmd' called less times than expected.");
  if (Mock.send_pump_cmd_CallbackFunctionPointer != NULL)
    Mock.send_pump_cmd_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.receive_pump_cmd_IgnoreBool)
    Mock.receive_pump_cmd_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.receive_pump_cmd_CallInstance, cmock_line, "Function 'receive_pump_cmd' called less times than expected.");
  if (Mock.receive_pump_cmd_CallbackFunctionPointer != NULL)
    Mock.receive_pump_cmd_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.pump_packetizer_IgnoreBool)
    Mock.pump_packetizer_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.pump_packetizer_CallInstance, cmock_line, "Function 'pump_packetizer' called less times than expected.");
  if (Mock.pump_packetizer_CallbackFunctionPointer != NULL)
    Mock.pump_packetizer_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.pump_reset_IgnoreBool)
    Mock.pump_reset_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.pump_reset_CallInstance, cmock_line, "Function 'pump_reset' called less times than expected.");
  if (Mock.pump_reset_CallbackFunctionPointer != NULL)
    Mock.pump_reset_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.pump_cmd_ack_IgnoreBool)
    Mock.pump_cmd_ack_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.pump_cmd_ack_CallInstance, cmock_line, "Function 'pump_cmd_ack' called less times than expected.");
  if (Mock.pump_cmd_ack_CallbackFunctionPointer != NULL)
    Mock.pump_cmd_ack_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.drive_status_IgnoreBool)
    Mock.drive_status_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.drive_status_CallInstance, cmock_line, "Function 'drive_status' called less times than expected.");
  if (Mock.drive_status_CallbackFunctionPointer != NULL)
    Mock.drive_status_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.pump_cmd_nack_IgnoreBool)
    Mock.pump_cmd_nack_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.pump_cmd_nack_CallInstance, cmock_line, "Function 'pump_cmd_nack' called less times than expected.");
  if (Mock.pump_cmd_nack_CallbackFunctionPointer != NULL)
    Mock.pump_cmd_nack_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.drive_power_mode_IgnoreBool)
    Mock.drive_power_mode_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.drive_power_mode_CallInstance, cmock_line, "Function 'drive_power_mode' called less times than expected.");
  if (Mock.drive_power_mode_CallbackFunctionPointer != NULL)
    Mock.drive_power_mode_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.probe_test_complete_IgnoreBool)
    Mock.probe_test_complete_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.probe_test_complete_CallInstance, cmock_line, "Function 'probe_test_complete' called less times than expected.");
  if (Mock.probe_test_complete_CallbackFunctionPointer != NULL)
    Mock.probe_test_complete_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.over_current_IgnoreBool)
    Mock.over_current_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.over_current_CallInstance, cmock_line, "Function 'over_current' called less times than expected.");
  if (Mock.over_current_CallbackFunctionPointer != NULL)
    Mock.over_current_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.over_energy_IgnoreBool)
    Mock.over_energy_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.over_energy_CallInstance, cmock_line, "Function 'over_energy' called less times than expected.");
  if (Mock.over_energy_CallbackFunctionPointer != NULL)
    Mock.over_energy_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.pump_uart_init_IgnoreBool)
    Mock.pump_uart_init_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.pump_uart_init_CallInstance, cmock_line, "Function 'pump_uart_init' called less times than expected.");
  if (Mock.pump_uart_init_CallbackFunctionPointer != NULL)
    Mock.pump_uart_init_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.pump_cmd_eack_IgnoreBool)
    Mock.pump_cmd_eack_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.pump_cmd_eack_CallInstance, cmock_line, "Function 'pump_cmd_eack' called less times than expected.");
  if (Mock.pump_cmd_eack_CallbackFunctionPointer != NULL)
    Mock.pump_cmd_eack_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.pump_startup_delay_IgnoreBool)
    Mock.pump_startup_delay_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.pump_startup_delay_CallInstance, cmock_line, "Function 'pump_startup_delay' called less times than expected.");
  if (Mock.pump_startup_delay_CallbackFunctionPointer != NULL)
    Mock.pump_startup_delay_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.pump_set_speed_IgnoreBool)
    Mock.pump_set_speed_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.pump_set_speed_CallInstance, cmock_line, "Function 'pump_set_speed' called less times than expected.");
  if (Mock.pump_set_speed_CallbackFunctionPointer != NULL)
    Mock.pump_set_speed_CallInstance = CMOCK_GUTS_NONE;
}

void Mockpump_Init(void)
{
  Mockpump_Destroy();
}

void Mockpump_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
  Mock.PumpPID_CallbackFunctionPointer = NULL;
  Mock.PumpPID_CallbackCalls = 0;
  Mock.pump_inactivity_monitor_CallbackFunctionPointer = NULL;
  Mock.pump_inactivity_monitor_CallbackCalls = 0;
  Mock.pump_speed_ctrl_CallbackFunctionPointer = NULL;
  Mock.pump_speed_ctrl_CallbackCalls = 0;
  Mock.PumpFIR_Init_CallbackFunctionPointer = NULL;
  Mock.PumpFIR_Init_CallbackCalls = 0;
  Mock.PumpUART4_Init_CallbackFunctionPointer = NULL;
  Mock.PumpUART4_Init_CallbackCalls = 0;
  Mock.send_pump_cmd_CallbackFunctionPointer = NULL;
  Mock.send_pump_cmd_CallbackCalls = 0;
  Mock.receive_pump_cmd_CallbackFunctionPointer = NULL;
  Mock.receive_pump_cmd_CallbackCalls = 0;
  Mock.pump_packetizer_CallbackFunctionPointer = NULL;
  Mock.pump_packetizer_CallbackCalls = 0;
  Mock.pump_reset_CallbackFunctionPointer = NULL;
  Mock.pump_reset_CallbackCalls = 0;
  Mock.pump_cmd_ack_CallbackFunctionPointer = NULL;
  Mock.pump_cmd_ack_CallbackCalls = 0;
  Mock.drive_status_CallbackFunctionPointer = NULL;
  Mock.drive_status_CallbackCalls = 0;
  Mock.pump_cmd_nack_CallbackFunctionPointer = NULL;
  Mock.pump_cmd_nack_CallbackCalls = 0;
  Mock.drive_power_mode_CallbackFunctionPointer = NULL;
  Mock.drive_power_mode_CallbackCalls = 0;
  Mock.probe_test_complete_CallbackFunctionPointer = NULL;
  Mock.probe_test_complete_CallbackCalls = 0;
  Mock.over_current_CallbackFunctionPointer = NULL;
  Mock.over_current_CallbackCalls = 0;
  Mock.over_energy_CallbackFunctionPointer = NULL;
  Mock.over_energy_CallbackCalls = 0;
  Mock.pump_uart_init_CallbackFunctionPointer = NULL;
  Mock.pump_uart_init_CallbackCalls = 0;
  Mock.pump_cmd_eack_CallbackFunctionPointer = NULL;
  Mock.pump_cmd_eack_CallbackCalls = 0;
  Mock.pump_startup_delay_CallbackFunctionPointer = NULL;
  Mock.pump_startup_delay_CallbackCalls = 0;
  Mock.pump_set_speed_CallbackFunctionPointer = NULL;
  Mock.pump_set_speed_CallbackCalls = 0;
}

float32_t PumpPID(q15_t pv, bool cmock_arg1)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_PumpPID_CALL_INSTANCE* cmock_call_instance = (CMOCK_PumpPID_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.PumpPID_CallInstance);
  Mock.PumpPID_CallInstance = CMock_Guts_MemNext(Mock.PumpPID_CallInstance);
  if (Mock.PumpPID_CallbackFunctionPointer != NULL)
  {
    return Mock.PumpPID_CallbackFunctionPointer(pv, cmock_arg1, Mock.PumpPID_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'PumpPID' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.PumpPID_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.PumpPID_FinalReturn;
    memcpy(&Mock.PumpPID_FinalReturn, &cmock_call_instance->ReturnVal, sizeof(float32_t));
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pv), (void*)(&pv), sizeof(q15_t), cmock_line, "Function 'PumpPID' called with unexpected value for argument 'pv'.");
  UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_cmock_arg1, cmock_arg1, cmock_line, "Function 'PumpPID' called with unexpected value for argument 'cmock_arg1'.");
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_PumpPID(CMOCK_PumpPID_CALL_INSTANCE* cmock_call_instance, q15_t pv, bool cmock_arg1)
{
  memcpy(&cmock_call_instance->Expected_pv, &pv, sizeof(q15_t));
  cmock_call_instance->Expected_cmock_arg1 = cmock_arg1;
}

void PumpPID_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, float32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_PumpPID_CALL_INSTANCE));
  CMOCK_PumpPID_CALL_INSTANCE* cmock_call_instance = (CMOCK_PumpPID_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.PumpPID_CallInstance = CMock_Guts_MemChain(Mock.PumpPID_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.PumpPID_IgnoreBool = (int)1;
}

void PumpPID_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, q15_t pv, bool cmock_arg1, float32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_PumpPID_CALL_INSTANCE));
  CMOCK_PumpPID_CALL_INSTANCE* cmock_call_instance = (CMOCK_PumpPID_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.PumpPID_CallInstance = CMock_Guts_MemChain(Mock.PumpPID_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_PumpPID(cmock_call_instance, pv, cmock_arg1);
  memcpy(&cmock_call_instance->ReturnVal, &cmock_to_return, sizeof(float32_t));
}

void PumpPID_StubWithCallback(CMOCK_PumpPID_CALLBACK Callback)
{
  Mock.PumpPID_CallbackFunctionPointer = Callback;
}

uint8_t pump_inactivity_monitor(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_pump_inactivity_monitor_CALL_INSTANCE* cmock_call_instance = (CMOCK_pump_inactivity_monitor_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.pump_inactivity_monitor_CallInstance);
  Mock.pump_inactivity_monitor_CallInstance = CMock_Guts_MemNext(Mock.pump_inactivity_monitor_CallInstance);
  if (Mock.pump_inactivity_monitor_CallbackFunctionPointer != NULL)
  {
    return Mock.pump_inactivity_monitor_CallbackFunctionPointer(Mock.pump_inactivity_monitor_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'pump_inactivity_monitor' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.pump_inactivity_monitor_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.pump_inactivity_monitor_FinalReturn;
    Mock.pump_inactivity_monitor_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void pump_inactivity_monitor_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pump_inactivity_monitor_CALL_INSTANCE));
  CMOCK_pump_inactivity_monitor_CALL_INSTANCE* cmock_call_instance = (CMOCK_pump_inactivity_monitor_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.pump_inactivity_monitor_CallInstance = CMock_Guts_MemChain(Mock.pump_inactivity_monitor_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.pump_inactivity_monitor_IgnoreBool = (int)1;
}

void pump_inactivity_monitor_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pump_inactivity_monitor_CALL_INSTANCE));
  CMOCK_pump_inactivity_monitor_CALL_INSTANCE* cmock_call_instance = (CMOCK_pump_inactivity_monitor_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.pump_inactivity_monitor_CallInstance = CMock_Guts_MemChain(Mock.pump_inactivity_monitor_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void pump_inactivity_monitor_StubWithCallback(CMOCK_pump_inactivity_monitor_CALLBACK Callback)
{
  Mock.pump_inactivity_monitor_CallbackFunctionPointer = Callback;
}

uint8_t pump_speed_ctrl(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_pump_speed_ctrl_CALL_INSTANCE* cmock_call_instance = (CMOCK_pump_speed_ctrl_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.pump_speed_ctrl_CallInstance);
  Mock.pump_speed_ctrl_CallInstance = CMock_Guts_MemNext(Mock.pump_speed_ctrl_CallInstance);
  if (Mock.pump_speed_ctrl_CallbackFunctionPointer != NULL)
  {
    return Mock.pump_speed_ctrl_CallbackFunctionPointer(Mock.pump_speed_ctrl_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'pump_speed_ctrl' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.pump_speed_ctrl_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.pump_speed_ctrl_FinalReturn;
    Mock.pump_speed_ctrl_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void pump_speed_ctrl_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pump_speed_ctrl_CALL_INSTANCE));
  CMOCK_pump_speed_ctrl_CALL_INSTANCE* cmock_call_instance = (CMOCK_pump_speed_ctrl_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.pump_speed_ctrl_CallInstance = CMock_Guts_MemChain(Mock.pump_speed_ctrl_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.pump_speed_ctrl_IgnoreBool = (int)1;
}

void pump_speed_ctrl_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pump_speed_ctrl_CALL_INSTANCE));
  CMOCK_pump_speed_ctrl_CALL_INSTANCE* cmock_call_instance = (CMOCK_pump_speed_ctrl_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.pump_speed_ctrl_CallInstance = CMock_Guts_MemChain(Mock.pump_speed_ctrl_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void pump_speed_ctrl_StubWithCallback(CMOCK_pump_speed_ctrl_CALLBACK Callback)
{
  Mock.pump_speed_ctrl_CallbackFunctionPointer = Callback;
}

void PumpFIR_Init(q15_t cmock_arg1)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_PumpFIR_Init_CALL_INSTANCE* cmock_call_instance = (CMOCK_PumpFIR_Init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.PumpFIR_Init_CallInstance);
  Mock.PumpFIR_Init_CallInstance = CMock_Guts_MemNext(Mock.PumpFIR_Init_CallInstance);
  if (Mock.PumpFIR_Init_CallbackFunctionPointer != NULL)
  {
    Mock.PumpFIR_Init_CallbackFunctionPointer(cmock_arg1, Mock.PumpFIR_Init_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'PumpFIR_Init' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.PumpFIR_Init_IgnoreBool)
  {
    return;
  }
  UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_cmock_arg1), (void*)(&cmock_arg1), sizeof(q15_t), cmock_line, "Function 'PumpFIR_Init' called with unexpected value for argument 'cmock_arg1'.");
}

void CMockExpectParameters_PumpFIR_Init(CMOCK_PumpFIR_Init_CALL_INSTANCE* cmock_call_instance, q15_t cmock_arg1)
{
  memcpy(&cmock_call_instance->Expected_cmock_arg1, &cmock_arg1, sizeof(q15_t));
}

void PumpFIR_Init_CMockIgnore(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_PumpFIR_Init_CALL_INSTANCE));
  CMOCK_PumpFIR_Init_CALL_INSTANCE* cmock_call_instance = (CMOCK_PumpFIR_Init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.PumpFIR_Init_CallInstance = CMock_Guts_MemChain(Mock.PumpFIR_Init_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  Mock.PumpFIR_Init_IgnoreBool = (int)1;
}

void PumpFIR_Init_CMockExpect(UNITY_LINE_TYPE cmock_line, q15_t cmock_arg1)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_PumpFIR_Init_CALL_INSTANCE));
  CMOCK_PumpFIR_Init_CALL_INSTANCE* cmock_call_instance = (CMOCK_PumpFIR_Init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.PumpFIR_Init_CallInstance = CMock_Guts_MemChain(Mock.PumpFIR_Init_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_PumpFIR_Init(cmock_call_instance, cmock_arg1);
}

void PumpFIR_Init_StubWithCallback(CMOCK_PumpFIR_Init_CALLBACK Callback)
{
  Mock.PumpFIR_Init_CallbackFunctionPointer = Callback;
}

void PumpUART4_Init(BAUD_RATE cmock_arg1)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_PumpUART4_Init_CALL_INSTANCE* cmock_call_instance = (CMOCK_PumpUART4_Init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.PumpUART4_Init_CallInstance);
  Mock.PumpUART4_Init_CallInstance = CMock_Guts_MemNext(Mock.PumpUART4_Init_CallInstance);
  if (Mock.PumpUART4_Init_CallbackFunctionPointer != NULL)
  {
    Mock.PumpUART4_Init_CallbackFunctionPointer(cmock_arg1, Mock.PumpUART4_Init_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'PumpUART4_Init' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.PumpUART4_Init_IgnoreBool)
  {
    return;
  }
  UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_cmock_arg1), (void*)(&cmock_arg1), sizeof(BAUD_RATE), cmock_line, "Function 'PumpUART4_Init' called with unexpected value for argument 'cmock_arg1'.");
}

void CMockExpectParameters_PumpUART4_Init(CMOCK_PumpUART4_Init_CALL_INSTANCE* cmock_call_instance, BAUD_RATE cmock_arg1)
{
  memcpy(&cmock_call_instance->Expected_cmock_arg1, &cmock_arg1, sizeof(BAUD_RATE));
}

void PumpUART4_Init_CMockIgnore(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_PumpUART4_Init_CALL_INSTANCE));
  CMOCK_PumpUART4_Init_CALL_INSTANCE* cmock_call_instance = (CMOCK_PumpUART4_Init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.PumpUART4_Init_CallInstance = CMock_Guts_MemChain(Mock.PumpUART4_Init_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  Mock.PumpUART4_Init_IgnoreBool = (int)1;
}

void PumpUART4_Init_CMockExpect(UNITY_LINE_TYPE cmock_line, BAUD_RATE cmock_arg1)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_PumpUART4_Init_CALL_INSTANCE));
  CMOCK_PumpUART4_Init_CALL_INSTANCE* cmock_call_instance = (CMOCK_PumpUART4_Init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.PumpUART4_Init_CallInstance = CMock_Guts_MemChain(Mock.PumpUART4_Init_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_PumpUART4_Init(cmock_call_instance, cmock_arg1);
}

void PumpUART4_Init_StubWithCallback(CMOCK_PumpUART4_Init_CALLBACK Callback)
{
  Mock.PumpUART4_Init_CallbackFunctionPointer = Callback;
}

void send_pump_cmd(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_send_pump_cmd_CALL_INSTANCE* cmock_call_instance = (CMOCK_send_pump_cmd_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.send_pump_cmd_CallInstance);
  Mock.send_pump_cmd_CallInstance = CMock_Guts_MemNext(Mock.send_pump_cmd_CallInstance);
  if (Mock.send_pump_cmd_CallbackFunctionPointer != NULL)
  {
    Mock.send_pump_cmd_CallbackFunctionPointer(Mock.send_pump_cmd_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'send_pump_cmd' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.send_pump_cmd_IgnoreBool)
  {
    return;
  }
}

void send_pump_cmd_CMockIgnore(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_send_pump_cmd_CALL_INSTANCE));
  CMOCK_send_pump_cmd_CALL_INSTANCE* cmock_call_instance = (CMOCK_send_pump_cmd_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.send_pump_cmd_CallInstance = CMock_Guts_MemChain(Mock.send_pump_cmd_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  Mock.send_pump_cmd_IgnoreBool = (int)1;
}

void send_pump_cmd_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_send_pump_cmd_CALL_INSTANCE));
  CMOCK_send_pump_cmd_CALL_INSTANCE* cmock_call_instance = (CMOCK_send_pump_cmd_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.send_pump_cmd_CallInstance = CMock_Guts_MemChain(Mock.send_pump_cmd_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
}

void send_pump_cmd_StubWithCallback(CMOCK_send_pump_cmd_CALLBACK Callback)
{
  Mock.send_pump_cmd_CallbackFunctionPointer = Callback;
}

uint8_t receive_pump_cmd(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_receive_pump_cmd_CALL_INSTANCE* cmock_call_instance = (CMOCK_receive_pump_cmd_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.receive_pump_cmd_CallInstance);
  Mock.receive_pump_cmd_CallInstance = CMock_Guts_MemNext(Mock.receive_pump_cmd_CallInstance);
  if (Mock.receive_pump_cmd_CallbackFunctionPointer != NULL)
  {
    return Mock.receive_pump_cmd_CallbackFunctionPointer(Mock.receive_pump_cmd_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'receive_pump_cmd' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.receive_pump_cmd_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.receive_pump_cmd_FinalReturn;
    Mock.receive_pump_cmd_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void receive_pump_cmd_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_receive_pump_cmd_CALL_INSTANCE));
  CMOCK_receive_pump_cmd_CALL_INSTANCE* cmock_call_instance = (CMOCK_receive_pump_cmd_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.receive_pump_cmd_CallInstance = CMock_Guts_MemChain(Mock.receive_pump_cmd_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.receive_pump_cmd_IgnoreBool = (int)1;
}

void receive_pump_cmd_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_receive_pump_cmd_CALL_INSTANCE));
  CMOCK_receive_pump_cmd_CALL_INSTANCE* cmock_call_instance = (CMOCK_receive_pump_cmd_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.receive_pump_cmd_CallInstance = CMock_Guts_MemChain(Mock.receive_pump_cmd_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void receive_pump_cmd_StubWithCallback(CMOCK_receive_pump_cmd_CALLBACK Callback)
{
  Mock.receive_pump_cmd_CallbackFunctionPointer = Callback;
}

uint8_t pump_packetizer(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_pump_packetizer_CALL_INSTANCE* cmock_call_instance = (CMOCK_pump_packetizer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.pump_packetizer_CallInstance);
  Mock.pump_packetizer_CallInstance = CMock_Guts_MemNext(Mock.pump_packetizer_CallInstance);
  if (Mock.pump_packetizer_CallbackFunctionPointer != NULL)
  {
    return Mock.pump_packetizer_CallbackFunctionPointer(Mock.pump_packetizer_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'pump_packetizer' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.pump_packetizer_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.pump_packetizer_FinalReturn;
    Mock.pump_packetizer_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void pump_packetizer_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pump_packetizer_CALL_INSTANCE));
  CMOCK_pump_packetizer_CALL_INSTANCE* cmock_call_instance = (CMOCK_pump_packetizer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.pump_packetizer_CallInstance = CMock_Guts_MemChain(Mock.pump_packetizer_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.pump_packetizer_IgnoreBool = (int)1;
}

void pump_packetizer_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pump_packetizer_CALL_INSTANCE));
  CMOCK_pump_packetizer_CALL_INSTANCE* cmock_call_instance = (CMOCK_pump_packetizer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.pump_packetizer_CallInstance = CMock_Guts_MemChain(Mock.pump_packetizer_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void pump_packetizer_StubWithCallback(CMOCK_pump_packetizer_CALLBACK Callback)
{
  Mock.pump_packetizer_CallbackFunctionPointer = Callback;
}

uint8_t pump_reset(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_pump_reset_CALL_INSTANCE* cmock_call_instance = (CMOCK_pump_reset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.pump_reset_CallInstance);
  Mock.pump_reset_CallInstance = CMock_Guts_MemNext(Mock.pump_reset_CallInstance);
  if (Mock.pump_reset_CallbackFunctionPointer != NULL)
  {
    return Mock.pump_reset_CallbackFunctionPointer(Mock.pump_reset_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'pump_reset' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.pump_reset_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.pump_reset_FinalReturn;
    Mock.pump_reset_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void pump_reset_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pump_reset_CALL_INSTANCE));
  CMOCK_pump_reset_CALL_INSTANCE* cmock_call_instance = (CMOCK_pump_reset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.pump_reset_CallInstance = CMock_Guts_MemChain(Mock.pump_reset_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.pump_reset_IgnoreBool = (int)1;
}

void pump_reset_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pump_reset_CALL_INSTANCE));
  CMOCK_pump_reset_CALL_INSTANCE* cmock_call_instance = (CMOCK_pump_reset_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.pump_reset_CallInstance = CMock_Guts_MemChain(Mock.pump_reset_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void pump_reset_StubWithCallback(CMOCK_pump_reset_CALLBACK Callback)
{
  Mock.pump_reset_CallbackFunctionPointer = Callback;
}

uint8_t pump_cmd_ack(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_pump_cmd_ack_CALL_INSTANCE* cmock_call_instance = (CMOCK_pump_cmd_ack_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.pump_cmd_ack_CallInstance);
  Mock.pump_cmd_ack_CallInstance = CMock_Guts_MemNext(Mock.pump_cmd_ack_CallInstance);
  if (Mock.pump_cmd_ack_CallbackFunctionPointer != NULL)
  {
    return Mock.pump_cmd_ack_CallbackFunctionPointer(Mock.pump_cmd_ack_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'pump_cmd_ack' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.pump_cmd_ack_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.pump_cmd_ack_FinalReturn;
    Mock.pump_cmd_ack_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void pump_cmd_ack_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pump_cmd_ack_CALL_INSTANCE));
  CMOCK_pump_cmd_ack_CALL_INSTANCE* cmock_call_instance = (CMOCK_pump_cmd_ack_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.pump_cmd_ack_CallInstance = CMock_Guts_MemChain(Mock.pump_cmd_ack_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.pump_cmd_ack_IgnoreBool = (int)1;
}

void pump_cmd_ack_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pump_cmd_ack_CALL_INSTANCE));
  CMOCK_pump_cmd_ack_CALL_INSTANCE* cmock_call_instance = (CMOCK_pump_cmd_ack_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.pump_cmd_ack_CallInstance = CMock_Guts_MemChain(Mock.pump_cmd_ack_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void pump_cmd_ack_StubWithCallback(CMOCK_pump_cmd_ack_CALLBACK Callback)
{
  Mock.pump_cmd_ack_CallbackFunctionPointer = Callback;
}

uint8_t drive_status(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_drive_status_CALL_INSTANCE* cmock_call_instance = (CMOCK_drive_status_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.drive_status_CallInstance);
  Mock.drive_status_CallInstance = CMock_Guts_MemNext(Mock.drive_status_CallInstance);
  if (Mock.drive_status_CallbackFunctionPointer != NULL)
  {
    return Mock.drive_status_CallbackFunctionPointer(Mock.drive_status_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'drive_status' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.drive_status_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.drive_status_FinalReturn;
    Mock.drive_status_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void drive_status_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_drive_status_CALL_INSTANCE));
  CMOCK_drive_status_CALL_INSTANCE* cmock_call_instance = (CMOCK_drive_status_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.drive_status_CallInstance = CMock_Guts_MemChain(Mock.drive_status_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.drive_status_IgnoreBool = (int)1;
}

void drive_status_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_drive_status_CALL_INSTANCE));
  CMOCK_drive_status_CALL_INSTANCE* cmock_call_instance = (CMOCK_drive_status_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.drive_status_CallInstance = CMock_Guts_MemChain(Mock.drive_status_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void drive_status_StubWithCallback(CMOCK_drive_status_CALLBACK Callback)
{
  Mock.drive_status_CallbackFunctionPointer = Callback;
}

uint8_t pump_cmd_nack(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_pump_cmd_nack_CALL_INSTANCE* cmock_call_instance = (CMOCK_pump_cmd_nack_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.pump_cmd_nack_CallInstance);
  Mock.pump_cmd_nack_CallInstance = CMock_Guts_MemNext(Mock.pump_cmd_nack_CallInstance);
  if (Mock.pump_cmd_nack_CallbackFunctionPointer != NULL)
  {
    return Mock.pump_cmd_nack_CallbackFunctionPointer(Mock.pump_cmd_nack_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'pump_cmd_nack' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.pump_cmd_nack_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.pump_cmd_nack_FinalReturn;
    Mock.pump_cmd_nack_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void pump_cmd_nack_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pump_cmd_nack_CALL_INSTANCE));
  CMOCK_pump_cmd_nack_CALL_INSTANCE* cmock_call_instance = (CMOCK_pump_cmd_nack_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.pump_cmd_nack_CallInstance = CMock_Guts_MemChain(Mock.pump_cmd_nack_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.pump_cmd_nack_IgnoreBool = (int)1;
}

void pump_cmd_nack_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pump_cmd_nack_CALL_INSTANCE));
  CMOCK_pump_cmd_nack_CALL_INSTANCE* cmock_call_instance = (CMOCK_pump_cmd_nack_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.pump_cmd_nack_CallInstance = CMock_Guts_MemChain(Mock.pump_cmd_nack_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void pump_cmd_nack_StubWithCallback(CMOCK_pump_cmd_nack_CALLBACK Callback)
{
  Mock.pump_cmd_nack_CallbackFunctionPointer = Callback;
}

uint8_t drive_power_mode(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_drive_power_mode_CALL_INSTANCE* cmock_call_instance = (CMOCK_drive_power_mode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.drive_power_mode_CallInstance);
  Mock.drive_power_mode_CallInstance = CMock_Guts_MemNext(Mock.drive_power_mode_CallInstance);
  if (Mock.drive_power_mode_CallbackFunctionPointer != NULL)
  {
    return Mock.drive_power_mode_CallbackFunctionPointer(Mock.drive_power_mode_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'drive_power_mode' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.drive_power_mode_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.drive_power_mode_FinalReturn;
    Mock.drive_power_mode_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void drive_power_mode_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_drive_power_mode_CALL_INSTANCE));
  CMOCK_drive_power_mode_CALL_INSTANCE* cmock_call_instance = (CMOCK_drive_power_mode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.drive_power_mode_CallInstance = CMock_Guts_MemChain(Mock.drive_power_mode_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.drive_power_mode_IgnoreBool = (int)1;
}

void drive_power_mode_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_drive_power_mode_CALL_INSTANCE));
  CMOCK_drive_power_mode_CALL_INSTANCE* cmock_call_instance = (CMOCK_drive_power_mode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.drive_power_mode_CallInstance = CMock_Guts_MemChain(Mock.drive_power_mode_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void drive_power_mode_StubWithCallback(CMOCK_drive_power_mode_CALLBACK Callback)
{
  Mock.drive_power_mode_CallbackFunctionPointer = Callback;
}

uint8_t probe_test_complete(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_probe_test_complete_CALL_INSTANCE* cmock_call_instance = (CMOCK_probe_test_complete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.probe_test_complete_CallInstance);
  Mock.probe_test_complete_CallInstance = CMock_Guts_MemNext(Mock.probe_test_complete_CallInstance);
  if (Mock.probe_test_complete_CallbackFunctionPointer != NULL)
  {
    return Mock.probe_test_complete_CallbackFunctionPointer(Mock.probe_test_complete_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'probe_test_complete' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.probe_test_complete_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.probe_test_complete_FinalReturn;
    Mock.probe_test_complete_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void probe_test_complete_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_probe_test_complete_CALL_INSTANCE));
  CMOCK_probe_test_complete_CALL_INSTANCE* cmock_call_instance = (CMOCK_probe_test_complete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.probe_test_complete_CallInstance = CMock_Guts_MemChain(Mock.probe_test_complete_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.probe_test_complete_IgnoreBool = (int)1;
}

void probe_test_complete_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_probe_test_complete_CALL_INSTANCE));
  CMOCK_probe_test_complete_CALL_INSTANCE* cmock_call_instance = (CMOCK_probe_test_complete_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.probe_test_complete_CallInstance = CMock_Guts_MemChain(Mock.probe_test_complete_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void probe_test_complete_StubWithCallback(CMOCK_probe_test_complete_CALLBACK Callback)
{
  Mock.probe_test_complete_CallbackFunctionPointer = Callback;
}

uint8_t over_current(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_over_current_CALL_INSTANCE* cmock_call_instance = (CMOCK_over_current_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.over_current_CallInstance);
  Mock.over_current_CallInstance = CMock_Guts_MemNext(Mock.over_current_CallInstance);
  if (Mock.over_current_CallbackFunctionPointer != NULL)
  {
    return Mock.over_current_CallbackFunctionPointer(Mock.over_current_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'over_current' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.over_current_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.over_current_FinalReturn;
    Mock.over_current_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void over_current_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_over_current_CALL_INSTANCE));
  CMOCK_over_current_CALL_INSTANCE* cmock_call_instance = (CMOCK_over_current_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.over_current_CallInstance = CMock_Guts_MemChain(Mock.over_current_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.over_current_IgnoreBool = (int)1;
}

void over_current_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_over_current_CALL_INSTANCE));
  CMOCK_over_current_CALL_INSTANCE* cmock_call_instance = (CMOCK_over_current_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.over_current_CallInstance = CMock_Guts_MemChain(Mock.over_current_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void over_current_StubWithCallback(CMOCK_over_current_CALLBACK Callback)
{
  Mock.over_current_CallbackFunctionPointer = Callback;
}

uint8_t over_energy(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_over_energy_CALL_INSTANCE* cmock_call_instance = (CMOCK_over_energy_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.over_energy_CallInstance);
  Mock.over_energy_CallInstance = CMock_Guts_MemNext(Mock.over_energy_CallInstance);
  if (Mock.over_energy_CallbackFunctionPointer != NULL)
  {
    return Mock.over_energy_CallbackFunctionPointer(Mock.over_energy_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'over_energy' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.over_energy_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.over_energy_FinalReturn;
    Mock.over_energy_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void over_energy_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_over_energy_CALL_INSTANCE));
  CMOCK_over_energy_CALL_INSTANCE* cmock_call_instance = (CMOCK_over_energy_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.over_energy_CallInstance = CMock_Guts_MemChain(Mock.over_energy_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.over_energy_IgnoreBool = (int)1;
}

void over_energy_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_over_energy_CALL_INSTANCE));
  CMOCK_over_energy_CALL_INSTANCE* cmock_call_instance = (CMOCK_over_energy_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.over_energy_CallInstance = CMock_Guts_MemChain(Mock.over_energy_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void over_energy_StubWithCallback(CMOCK_over_energy_CALLBACK Callback)
{
  Mock.over_energy_CallbackFunctionPointer = Callback;
}

uint8_t pump_uart_init(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_pump_uart_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_pump_uart_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.pump_uart_init_CallInstance);
  Mock.pump_uart_init_CallInstance = CMock_Guts_MemNext(Mock.pump_uart_init_CallInstance);
  if (Mock.pump_uart_init_CallbackFunctionPointer != NULL)
  {
    return Mock.pump_uart_init_CallbackFunctionPointer(Mock.pump_uart_init_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'pump_uart_init' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.pump_uart_init_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.pump_uart_init_FinalReturn;
    Mock.pump_uart_init_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void pump_uart_init_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pump_uart_init_CALL_INSTANCE));
  CMOCK_pump_uart_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_pump_uart_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.pump_uart_init_CallInstance = CMock_Guts_MemChain(Mock.pump_uart_init_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.pump_uart_init_IgnoreBool = (int)1;
}

void pump_uart_init_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pump_uart_init_CALL_INSTANCE));
  CMOCK_pump_uart_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_pump_uart_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.pump_uart_init_CallInstance = CMock_Guts_MemChain(Mock.pump_uart_init_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void pump_uart_init_StubWithCallback(CMOCK_pump_uart_init_CALLBACK Callback)
{
  Mock.pump_uart_init_CallbackFunctionPointer = Callback;
}

uint8_t pump_cmd_eack(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_pump_cmd_eack_CALL_INSTANCE* cmock_call_instance = (CMOCK_pump_cmd_eack_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.pump_cmd_eack_CallInstance);
  Mock.pump_cmd_eack_CallInstance = CMock_Guts_MemNext(Mock.pump_cmd_eack_CallInstance);
  if (Mock.pump_cmd_eack_CallbackFunctionPointer != NULL)
  {
    return Mock.pump_cmd_eack_CallbackFunctionPointer(Mock.pump_cmd_eack_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'pump_cmd_eack' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.pump_cmd_eack_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.pump_cmd_eack_FinalReturn;
    Mock.pump_cmd_eack_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void pump_cmd_eack_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pump_cmd_eack_CALL_INSTANCE));
  CMOCK_pump_cmd_eack_CALL_INSTANCE* cmock_call_instance = (CMOCK_pump_cmd_eack_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.pump_cmd_eack_CallInstance = CMock_Guts_MemChain(Mock.pump_cmd_eack_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.pump_cmd_eack_IgnoreBool = (int)1;
}

void pump_cmd_eack_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pump_cmd_eack_CALL_INSTANCE));
  CMOCK_pump_cmd_eack_CALL_INSTANCE* cmock_call_instance = (CMOCK_pump_cmd_eack_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.pump_cmd_eack_CallInstance = CMock_Guts_MemChain(Mock.pump_cmd_eack_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void pump_cmd_eack_StubWithCallback(CMOCK_pump_cmd_eack_CALLBACK Callback)
{
  Mock.pump_cmd_eack_CallbackFunctionPointer = Callback;
}

uint8_t pump_startup_delay(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_pump_startup_delay_CALL_INSTANCE* cmock_call_instance = (CMOCK_pump_startup_delay_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.pump_startup_delay_CallInstance);
  Mock.pump_startup_delay_CallInstance = CMock_Guts_MemNext(Mock.pump_startup_delay_CallInstance);
  if (Mock.pump_startup_delay_CallbackFunctionPointer != NULL)
  {
    return Mock.pump_startup_delay_CallbackFunctionPointer(Mock.pump_startup_delay_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'pump_startup_delay' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.pump_startup_delay_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.pump_startup_delay_FinalReturn;
    Mock.pump_startup_delay_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void pump_startup_delay_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pump_startup_delay_CALL_INSTANCE));
  CMOCK_pump_startup_delay_CALL_INSTANCE* cmock_call_instance = (CMOCK_pump_startup_delay_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.pump_startup_delay_CallInstance = CMock_Guts_MemChain(Mock.pump_startup_delay_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.pump_startup_delay_IgnoreBool = (int)1;
}

void pump_startup_delay_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pump_startup_delay_CALL_INSTANCE));
  CMOCK_pump_startup_delay_CALL_INSTANCE* cmock_call_instance = (CMOCK_pump_startup_delay_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.pump_startup_delay_CallInstance = CMock_Guts_MemChain(Mock.pump_startup_delay_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void pump_startup_delay_StubWithCallback(CMOCK_pump_startup_delay_CALLBACK Callback)
{
  Mock.pump_startup_delay_CallbackFunctionPointer = Callback;
}

void pump_set_speed(float Speed)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_pump_set_speed_CALL_INSTANCE* cmock_call_instance = (CMOCK_pump_set_speed_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.pump_set_speed_CallInstance);
  Mock.pump_set_speed_CallInstance = CMock_Guts_MemNext(Mock.pump_set_speed_CallInstance);
  if (Mock.pump_set_speed_CallbackFunctionPointer != NULL)
  {
    Mock.pump_set_speed_CallbackFunctionPointer(Speed, Mock.pump_set_speed_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'pump_set_speed' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.pump_set_speed_IgnoreBool)
  {
    return;
  }
  UNITY_TEST_ASSERT_EQUAL_FLOAT(cmock_call_instance->Expected_Speed, Speed, cmock_line, "Function 'pump_set_speed' called with unexpected value for argument 'Speed'.");
}

void CMockExpectParameters_pump_set_speed(CMOCK_pump_set_speed_CALL_INSTANCE* cmock_call_instance, float Speed)
{
  cmock_call_instance->Expected_Speed = Speed;
}

void pump_set_speed_CMockIgnore(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pump_set_speed_CALL_INSTANCE));
  CMOCK_pump_set_speed_CALL_INSTANCE* cmock_call_instance = (CMOCK_pump_set_speed_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.pump_set_speed_CallInstance = CMock_Guts_MemChain(Mock.pump_set_speed_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  Mock.pump_set_speed_IgnoreBool = (int)1;
}

void pump_set_speed_CMockExpect(UNITY_LINE_TYPE cmock_line, float Speed)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pump_set_speed_CALL_INSTANCE));
  CMOCK_pump_set_speed_CALL_INSTANCE* cmock_call_instance = (CMOCK_pump_set_speed_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.pump_set_speed_CallInstance = CMock_Guts_MemChain(Mock.pump_set_speed_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_pump_set_speed(cmock_call_instance, Speed);
}

void pump_set_speed_StubWithCallback(CMOCK_pump_set_speed_CALLBACK Callback)
{
  Mock.pump_set_speed_CallbackFunctionPointer = Callback;
}

