/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "unity.h"
#include "cmock.h"
#include "Mocknotifications.h"

typedef struct _CMOCK_notification_manager_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;

} CMOCK_notification_manager_CALL_INSTANCE;

typedef struct _CMOCK_gui_com_fault_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_gui_com_fault_CALL_INSTANCE;

typedef struct _CMOCK_peak_hit_cntr_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_peak_hit_cntr_CALL_INSTANCE;

typedef struct _CMOCK_legacy_wand_short_error_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_legacy_wand_short_error_CALL_INSTANCE;

typedef struct _CMOCK_reset_error_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_reset_error_CALL_INSTANCE;

typedef struct _CMOCK_suction_tube_error_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_suction_tube_error_CALL_INSTANCE;

typedef struct _CMOCK_no_ambient_error_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_no_ambient_error_CALL_INSTANCE;

typedef struct _CMOCK_clear_internal_temp_error_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_clear_internal_temp_error_CALL_INSTANCE;

typedef struct _CMOCK_internal_temp_error_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_internal_temp_error_CALL_INSTANCE;

typedef struct _CMOCK_adc_boundary_fault_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_adc_boundary_fault_CALL_INSTANCE;

typedef struct _CMOCK_crc_fault_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_crc_fault_CALL_INSTANCE;

typedef struct _CMOCK_wand_switch_stuck_fault_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_wand_switch_stuck_fault_CALL_INSTANCE;

typedef struct _CMOCK_fp_switch_stuck_fault_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_fp_switch_stuck_fault_CALL_INSTANCE;

typedef struct _CMOCK_pump_fault_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_pump_fault_CALL_INSTANCE;

typedef struct _CMOCK_vmod_fault_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_vmod_fault_CALL_INSTANCE;

typedef struct _CMOCK_can_timeout_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_can_timeout_CALL_INSTANCE;

typedef struct _CMOCK_internal_temp_fault_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_internal_temp_fault_CALL_INSTANCE;

typedef struct _CMOCK_wdog_fault_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_wdog_fault_CALL_INSTANCE;

typedef struct _CMOCK_fault_init_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_fault_init_CALL_INSTANCE;

typedef struct _CMOCK_date_time_fault_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_date_time_fault_CALL_INSTANCE;

typedef struct _CMOCK_serial_num_fault_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_serial_num_fault_CALL_INSTANCE;

typedef struct _CMOCK_wand_expired_error_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_wand_expired_error_CALL_INSTANCE;

typedef struct _CMOCK_wand_use_limit_error_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_wand_use_limit_error_CALL_INSTANCE;

typedef struct _CMOCK_clear_wand_expired_error_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_clear_wand_expired_error_CALL_INSTANCE;

typedef struct _CMOCK_clear_wand_use_limit_error_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_clear_wand_use_limit_error_CALL_INSTANCE;

typedef struct _CMOCK_wand_id_error_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_wand_id_error_CALL_INSTANCE;

typedef struct _CMOCK_lw_id_error_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_lw_id_error_CALL_INSTANCE;

typedef struct _CMOCK_wand_disconnected_error_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_wand_disconnected_error_CALL_INSTANCE;

typedef struct _CMOCK_check_electrode_error_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_check_electrode_error_CALL_INSTANCE;

typedef struct _CMOCK_wand_error_type_decipher_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;
  NOTIFY_TXT Expected_cmock_arg1;

} CMOCK_wand_error_type_decipher_CALL_INSTANCE;

typedef struct _CMOCK_clear_wand_errors_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint32_t ReturnVal;

} CMOCK_clear_wand_errors_CALL_INSTANCE;

typedef struct _CMOCK_lw_incompatible_error_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_lw_incompatible_error_CALL_INSTANCE;

typedef struct _CMOCK_legacy_wand_disconnected_error_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_legacy_wand_disconnected_error_CALL_INSTANCE;

typedef struct _CMOCK_gen_com_fault_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_gen_com_fault_CALL_INSTANCE;

typedef struct _CMOCK_two_wand_disconnected_error_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_two_wand_disconnected_error_CALL_INSTANCE;

typedef struct _CMOCK_multiple_button_pressed_test_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint32_t ReturnVal;
  uint32_t Expected_cmock_arg1;

} CMOCK_multiple_button_pressed_test_CALL_INSTANCE;

typedef struct _CMOCK_ui_fault_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_ui_fault_CALL_INSTANCE;

typedef struct _CMOCK_smart_wand_incompatible_error_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_smart_wand_incompatible_error_CALL_INSTANCE;

static struct MocknotificationsInstance
{
  int notification_manager_IgnoreBool;
  CMOCK_notification_manager_CALLBACK notification_manager_CallbackFunctionPointer;
  int notification_manager_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE notification_manager_CallInstance;
  int gui_com_fault_IgnoreBool;
  uint8_t gui_com_fault_FinalReturn;
  CMOCK_gui_com_fault_CALLBACK gui_com_fault_CallbackFunctionPointer;
  int gui_com_fault_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gui_com_fault_CallInstance;
  int peak_hit_cntr_IgnoreBool;
  uint8_t peak_hit_cntr_FinalReturn;
  CMOCK_peak_hit_cntr_CALLBACK peak_hit_cntr_CallbackFunctionPointer;
  int peak_hit_cntr_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE peak_hit_cntr_CallInstance;
  int legacy_wand_short_error_IgnoreBool;
  uint8_t legacy_wand_short_error_FinalReturn;
  CMOCK_legacy_wand_short_error_CALLBACK legacy_wand_short_error_CallbackFunctionPointer;
  int legacy_wand_short_error_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE legacy_wand_short_error_CallInstance;
  int reset_error_IgnoreBool;
  uint8_t reset_error_FinalReturn;
  CMOCK_reset_error_CALLBACK reset_error_CallbackFunctionPointer;
  int reset_error_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE reset_error_CallInstance;
  int suction_tube_error_IgnoreBool;
  uint8_t suction_tube_error_FinalReturn;
  CMOCK_suction_tube_error_CALLBACK suction_tube_error_CallbackFunctionPointer;
  int suction_tube_error_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE suction_tube_error_CallInstance;
  int no_ambient_error_IgnoreBool;
  uint8_t no_ambient_error_FinalReturn;
  CMOCK_no_ambient_error_CALLBACK no_ambient_error_CallbackFunctionPointer;
  int no_ambient_error_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE no_ambient_error_CallInstance;
  int clear_internal_temp_error_IgnoreBool;
  uint8_t clear_internal_temp_error_FinalReturn;
  CMOCK_clear_internal_temp_error_CALLBACK clear_internal_temp_error_CallbackFunctionPointer;
  int clear_internal_temp_error_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE clear_internal_temp_error_CallInstance;
  int internal_temp_error_IgnoreBool;
  uint8_t internal_temp_error_FinalReturn;
  CMOCK_internal_temp_error_CALLBACK internal_temp_error_CallbackFunctionPointer;
  int internal_temp_error_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE internal_temp_error_CallInstance;
  int adc_boundary_fault_IgnoreBool;
  uint8_t adc_boundary_fault_FinalReturn;
  CMOCK_adc_boundary_fault_CALLBACK adc_boundary_fault_CallbackFunctionPointer;
  int adc_boundary_fault_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE adc_boundary_fault_CallInstance;
  int crc_fault_IgnoreBool;
  uint8_t crc_fault_FinalReturn;
  CMOCK_crc_fault_CALLBACK crc_fault_CallbackFunctionPointer;
  int crc_fault_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE crc_fault_CallInstance;
  int wand_switch_stuck_fault_IgnoreBool;
  uint8_t wand_switch_stuck_fault_FinalReturn;
  CMOCK_wand_switch_stuck_fault_CALLBACK wand_switch_stuck_fault_CallbackFunctionPointer;
  int wand_switch_stuck_fault_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE wand_switch_stuck_fault_CallInstance;
  int fp_switch_stuck_fault_IgnoreBool;
  uint8_t fp_switch_stuck_fault_FinalReturn;
  CMOCK_fp_switch_stuck_fault_CALLBACK fp_switch_stuck_fault_CallbackFunctionPointer;
  int fp_switch_stuck_fault_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE fp_switch_stuck_fault_CallInstance;
  int pump_fault_IgnoreBool;
  uint8_t pump_fault_FinalReturn;
  CMOCK_pump_fault_CALLBACK pump_fault_CallbackFunctionPointer;
  int pump_fault_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE pump_fault_CallInstance;
  int vmod_fault_IgnoreBool;
  uint8_t vmod_fault_FinalReturn;
  CMOCK_vmod_fault_CALLBACK vmod_fault_CallbackFunctionPointer;
  int vmod_fault_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vmod_fault_CallInstance;
  int can_timeout_IgnoreBool;
  uint8_t can_timeout_FinalReturn;
  CMOCK_can_timeout_CALLBACK can_timeout_CallbackFunctionPointer;
  int can_timeout_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE can_timeout_CallInstance;
  int internal_temp_fault_IgnoreBool;
  uint8_t internal_temp_fault_FinalReturn;
  CMOCK_internal_temp_fault_CALLBACK internal_temp_fault_CallbackFunctionPointer;
  int internal_temp_fault_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE internal_temp_fault_CallInstance;
  int wdog_fault_IgnoreBool;
  uint8_t wdog_fault_FinalReturn;
  CMOCK_wdog_fault_CALLBACK wdog_fault_CallbackFunctionPointer;
  int wdog_fault_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE wdog_fault_CallInstance;
  int fault_init_IgnoreBool;
  uint8_t fault_init_FinalReturn;
  CMOCK_fault_init_CALLBACK fault_init_CallbackFunctionPointer;
  int fault_init_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE fault_init_CallInstance;
  int date_time_fault_IgnoreBool;
  uint8_t date_time_fault_FinalReturn;
  CMOCK_date_time_fault_CALLBACK date_time_fault_CallbackFunctionPointer;
  int date_time_fault_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE date_time_fault_CallInstance;
  int serial_num_fault_IgnoreBool;
  uint8_t serial_num_fault_FinalReturn;
  CMOCK_serial_num_fault_CALLBACK serial_num_fault_CallbackFunctionPointer;
  int serial_num_fault_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE serial_num_fault_CallInstance;
  int wand_expired_error_IgnoreBool;
  uint8_t wand_expired_error_FinalReturn;
  CMOCK_wand_expired_error_CALLBACK wand_expired_error_CallbackFunctionPointer;
  int wand_expired_error_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE wand_expired_error_CallInstance;
  int wand_use_limit_error_IgnoreBool;
  uint8_t wand_use_limit_error_FinalReturn;
  CMOCK_wand_use_limit_error_CALLBACK wand_use_limit_error_CallbackFunctionPointer;
  int wand_use_limit_error_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE wand_use_limit_error_CallInstance;
  int clear_wand_expired_error_IgnoreBool;
  uint8_t clear_wand_expired_error_FinalReturn;
  CMOCK_clear_wand_expired_error_CALLBACK clear_wand_expired_error_CallbackFunctionPointer;
  int clear_wand_expired_error_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE clear_wand_expired_error_CallInstance;
  int clear_wand_use_limit_error_IgnoreBool;
  uint8_t clear_wand_use_limit_error_FinalReturn;
  CMOCK_clear_wand_use_limit_error_CALLBACK clear_wand_use_limit_error_CallbackFunctionPointer;
  int clear_wand_use_limit_error_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE clear_wand_use_limit_error_CallInstance;
  int wand_id_error_IgnoreBool;
  uint8_t wand_id_error_FinalReturn;
  CMOCK_wand_id_error_CALLBACK wand_id_error_CallbackFunctionPointer;
  int wand_id_error_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE wand_id_error_CallInstance;
  int lw_id_error_IgnoreBool;
  uint8_t lw_id_error_FinalReturn;
  CMOCK_lw_id_error_CALLBACK lw_id_error_CallbackFunctionPointer;
  int lw_id_error_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE lw_id_error_CallInstance;
  int wand_disconnected_error_IgnoreBool;
  uint8_t wand_disconnected_error_FinalReturn;
  CMOCK_wand_disconnected_error_CALLBACK wand_disconnected_error_CallbackFunctionPointer;
  int wand_disconnected_error_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE wand_disconnected_error_CallInstance;
  int check_electrode_error_IgnoreBool;
  uint8_t check_electrode_error_FinalReturn;
  CMOCK_check_electrode_error_CALLBACK check_electrode_error_CallbackFunctionPointer;
  int check_electrode_error_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE check_electrode_error_CallInstance;
  int wand_error_type_decipher_IgnoreBool;
  uint8_t wand_error_type_decipher_FinalReturn;
  CMOCK_wand_error_type_decipher_CALLBACK wand_error_type_decipher_CallbackFunctionPointer;
  int wand_error_type_decipher_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE wand_error_type_decipher_CallInstance;
  int clear_wand_errors_IgnoreBool;
  uint32_t clear_wand_errors_FinalReturn;
  CMOCK_clear_wand_errors_CALLBACK clear_wand_errors_CallbackFunctionPointer;
  int clear_wand_errors_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE clear_wand_errors_CallInstance;
  int lw_incompatible_error_IgnoreBool;
  uint8_t lw_incompatible_error_FinalReturn;
  CMOCK_lw_incompatible_error_CALLBACK lw_incompatible_error_CallbackFunctionPointer;
  int lw_incompatible_error_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE lw_incompatible_error_CallInstance;
  int legacy_wand_disconnected_error_IgnoreBool;
  uint8_t legacy_wand_disconnected_error_FinalReturn;
  CMOCK_legacy_wand_disconnected_error_CALLBACK legacy_wand_disconnected_error_CallbackFunctionPointer;
  int legacy_wand_disconnected_error_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE legacy_wand_disconnected_error_CallInstance;
  int gen_com_fault_IgnoreBool;
  uint8_t gen_com_fault_FinalReturn;
  CMOCK_gen_com_fault_CALLBACK gen_com_fault_CallbackFunctionPointer;
  int gen_com_fault_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gen_com_fault_CallInstance;
  int two_wand_disconnected_error_IgnoreBool;
  uint8_t two_wand_disconnected_error_FinalReturn;
  CMOCK_two_wand_disconnected_error_CALLBACK two_wand_disconnected_error_CallbackFunctionPointer;
  int two_wand_disconnected_error_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE two_wand_disconnected_error_CallInstance;
  int multiple_button_pressed_test_IgnoreBool;
  uint32_t multiple_button_pressed_test_FinalReturn;
  CMOCK_multiple_button_pressed_test_CALLBACK multiple_button_pressed_test_CallbackFunctionPointer;
  int multiple_button_pressed_test_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE multiple_button_pressed_test_CallInstance;
  int ui_fault_IgnoreBool;
  uint8_t ui_fault_FinalReturn;
  CMOCK_ui_fault_CALLBACK ui_fault_CallbackFunctionPointer;
  int ui_fault_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE ui_fault_CallInstance;
  int smart_wand_incompatible_error_IgnoreBool;
  uint8_t smart_wand_incompatible_error_FinalReturn;
  CMOCK_smart_wand_incompatible_error_CALLBACK smart_wand_incompatible_error_CallbackFunctionPointer;
  int smart_wand_incompatible_error_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE smart_wand_incompatible_error_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void Mocknotifications_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  if (Mock.notification_manager_IgnoreBool)
    Mock.notification_manager_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.notification_manager_CallInstance, cmock_line, "Function 'notification_manager' called less times than expected.");
  if (Mock.notification_manager_CallbackFunctionPointer != NULL)
    Mock.notification_manager_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.gui_com_fault_IgnoreBool)
    Mock.gui_com_fault_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.gui_com_fault_CallInstance, cmock_line, "Function 'gui_com_fault' called less times than expected.");
  if (Mock.gui_com_fault_CallbackFunctionPointer != NULL)
    Mock.gui_com_fault_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.peak_hit_cntr_IgnoreBool)
    Mock.peak_hit_cntr_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.peak_hit_cntr_CallInstance, cmock_line, "Function 'peak_hit_cntr' called less times than expected.");
  if (Mock.peak_hit_cntr_CallbackFunctionPointer != NULL)
    Mock.peak_hit_cntr_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.legacy_wand_short_error_IgnoreBool)
    Mock.legacy_wand_short_error_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.legacy_wand_short_error_CallInstance, cmock_line, "Function 'legacy_wand_short_error' called less times than expected.");
  if (Mock.legacy_wand_short_error_CallbackFunctionPointer != NULL)
    Mock.legacy_wand_short_error_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.reset_error_IgnoreBool)
    Mock.reset_error_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.reset_error_CallInstance, cmock_line, "Function 'reset_error' called less times than expected.");
  if (Mock.reset_error_CallbackFunctionPointer != NULL)
    Mock.reset_error_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.suction_tube_error_IgnoreBool)
    Mock.suction_tube_error_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.suction_tube_error_CallInstance, cmock_line, "Function 'suction_tube_error' called less times than expected.");
  if (Mock.suction_tube_error_CallbackFunctionPointer != NULL)
    Mock.suction_tube_error_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.no_ambient_error_IgnoreBool)
    Mock.no_ambient_error_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.no_ambient_error_CallInstance, cmock_line, "Function 'no_ambient_error' called less times than expected.");
  if (Mock.no_ambient_error_CallbackFunctionPointer != NULL)
    Mock.no_ambient_error_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.clear_internal_temp_error_IgnoreBool)
    Mock.clear_internal_temp_error_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.clear_internal_temp_error_CallInstance, cmock_line, "Function 'clear_internal_temp_error' called less times than expected.");
  if (Mock.clear_internal_temp_error_CallbackFunctionPointer != NULL)
    Mock.clear_internal_temp_error_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.internal_temp_error_IgnoreBool)
    Mock.internal_temp_error_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.internal_temp_error_CallInstance, cmock_line, "Function 'internal_temp_error' called less times than expected.");
  if (Mock.internal_temp_error_CallbackFunctionPointer != NULL)
    Mock.internal_temp_error_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.adc_boundary_fault_IgnoreBool)
    Mock.adc_boundary_fault_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.adc_boundary_fault_CallInstance, cmock_line, "Function 'adc_boundary_fault' called less times than expected.");
  if (Mock.adc_boundary_fault_CallbackFunctionPointer != NULL)
    Mock.adc_boundary_fault_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.crc_fault_IgnoreBool)
    Mock.crc_fault_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.crc_fault_CallInstance, cmock_line, "Function 'crc_fault' called less times than expected.");
  if (Mock.crc_fault_CallbackFunctionPointer != NULL)
    Mock.crc_fault_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.wand_switch_stuck_fault_IgnoreBool)
    Mock.wand_switch_stuck_fault_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.wand_switch_stuck_fault_CallInstance, cmock_line, "Function 'wand_switch_stuck_fault' called less times than expected.");
  if (Mock.wand_switch_stuck_fault_CallbackFunctionPointer != NULL)
    Mock.wand_switch_stuck_fault_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.fp_switch_stuck_fault_IgnoreBool)
    Mock.fp_switch_stuck_fault_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.fp_switch_stuck_fault_CallInstance, cmock_line, "Function 'fp_switch_stuck_fault' called less times than expected.");
  if (Mock.fp_switch_stuck_fault_CallbackFunctionPointer != NULL)
    Mock.fp_switch_stuck_fault_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.pump_fault_IgnoreBool)
    Mock.pump_fault_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.pump_fault_CallInstance, cmock_line, "Function 'pump_fault' called less times than expected.");
  if (Mock.pump_fault_CallbackFunctionPointer != NULL)
    Mock.pump_fault_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.vmod_fault_IgnoreBool)
    Mock.vmod_fault_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.vmod_fault_CallInstance, cmock_line, "Function 'vmod_fault' called less times than expected.");
  if (Mock.vmod_fault_CallbackFunctionPointer != NULL)
    Mock.vmod_fault_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.can_timeout_IgnoreBool)
    Mock.can_timeout_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.can_timeout_CallInstance, cmock_line, "Function 'can_timeout' called less times than expected.");
  if (Mock.can_timeout_CallbackFunctionPointer != NULL)
    Mock.can_timeout_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.internal_temp_fault_IgnoreBool)
    Mock.internal_temp_fault_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.internal_temp_fault_CallInstance, cmock_line, "Function 'internal_temp_fault' called less times than expected.");
  if (Mock.internal_temp_fault_CallbackFunctionPointer != NULL)
    Mock.internal_temp_fault_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.wdog_fault_IgnoreBool)
    Mock.wdog_fault_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.wdog_fault_CallInstance, cmock_line, "Function 'wdog_fault' called less times than expected.");
  if (Mock.wdog_fault_CallbackFunctionPointer != NULL)
    Mock.wdog_fault_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.fault_init_IgnoreBool)
    Mock.fault_init_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.fault_init_CallInstance, cmock_line, "Function 'fault_init' called less times than expected.");
  if (Mock.fault_init_CallbackFunctionPointer != NULL)
    Mock.fault_init_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.date_time_fault_IgnoreBool)
    Mock.date_time_fault_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.date_time_fault_CallInstance, cmock_line, "Function 'date_time_fault' called less times than expected.");
  if (Mock.date_time_fault_CallbackFunctionPointer != NULL)
    Mock.date_time_fault_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.serial_num_fault_IgnoreBool)
    Mock.serial_num_fault_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.serial_num_fault_CallInstance, cmock_line, "Function 'serial_num_fault' called less times than expected.");
  if (Mock.serial_num_fault_CallbackFunctionPointer != NULL)
    Mock.serial_num_fault_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.wand_expired_error_IgnoreBool)
    Mock.wand_expired_error_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.wand_expired_error_CallInstance, cmock_line, "Function 'wand_expired_error' called less times than expected.");
  if (Mock.wand_expired_error_CallbackFunctionPointer != NULL)
    Mock.wand_expired_error_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.wand_use_limit_error_IgnoreBool)
    Mock.wand_use_limit_error_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.wand_use_limit_error_CallInstance, cmock_line, "Function 'wand_use_limit_error' called less times than expected.");
  if (Mock.wand_use_limit_error_CallbackFunctionPointer != NULL)
    Mock.wand_use_limit_error_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.clear_wand_expired_error_IgnoreBool)
    Mock.clear_wand_expired_error_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.clear_wand_expired_error_CallInstance, cmock_line, "Function 'clear_wand_expired_error' called less times than expected.");
  if (Mock.clear_wand_expired_error_CallbackFunctionPointer != NULL)
    Mock.clear_wand_expired_error_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.clear_wand_use_limit_error_IgnoreBool)
    Mock.clear_wand_use_limit_error_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.clear_wand_use_limit_error_CallInstance, cmock_line, "Function 'clear_wand_use_limit_error' called less times than expected.");
  if (Mock.clear_wand_use_limit_error_CallbackFunctionPointer != NULL)
    Mock.clear_wand_use_limit_error_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.wand_id_error_IgnoreBool)
    Mock.wand_id_error_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.wand_id_error_CallInstance, cmock_line, "Function 'wand_id_error' called less times than expected.");
  if (Mock.wand_id_error_CallbackFunctionPointer != NULL)
    Mock.wand_id_error_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.lw_id_error_IgnoreBool)
    Mock.lw_id_error_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.lw_id_error_CallInstance, cmock_line, "Function 'lw_id_error' called less times than expected.");
  if (Mock.lw_id_error_CallbackFunctionPointer != NULL)
    Mock.lw_id_error_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.wand_disconnected_error_IgnoreBool)
    Mock.wand_disconnected_error_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.wand_disconnected_error_CallInstance, cmock_line, "Function 'wand_disconnected_error' called less times than expected.");
  if (Mock.wand_disconnected_error_CallbackFunctionPointer != NULL)
    Mock.wand_disconnected_error_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.check_electrode_error_IgnoreBool)
    Mock.check_electrode_error_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.check_electrode_error_CallInstance, cmock_line, "Function 'check_electrode_error' called less times than expected.");
  if (Mock.check_electrode_error_CallbackFunctionPointer != NULL)
    Mock.check_electrode_error_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.wand_error_type_decipher_IgnoreBool)
    Mock.wand_error_type_decipher_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.wand_error_type_decipher_CallInstance, cmock_line, "Function 'wand_error_type_decipher' called less times than expected.");
  if (Mock.wand_error_type_decipher_CallbackFunctionPointer != NULL)
    Mock.wand_error_type_decipher_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.clear_wand_errors_IgnoreBool)
    Mock.clear_wand_errors_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.clear_wand_errors_CallInstance, cmock_line, "Function 'clear_wand_errors' called less times than expected.");
  if (Mock.clear_wand_errors_CallbackFunctionPointer != NULL)
    Mock.clear_wand_errors_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.lw_incompatible_error_IgnoreBool)
    Mock.lw_incompatible_error_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.lw_incompatible_error_CallInstance, cmock_line, "Function 'lw_incompatible_error' called less times than expected.");
  if (Mock.lw_incompatible_error_CallbackFunctionPointer != NULL)
    Mock.lw_incompatible_error_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.legacy_wand_disconnected_error_IgnoreBool)
    Mock.legacy_wand_disconnected_error_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.legacy_wand_disconnected_error_CallInstance, cmock_line, "Function 'legacy_wand_disconnected_error' called less times than expected.");
  if (Mock.legacy_wand_disconnected_error_CallbackFunctionPointer != NULL)
    Mock.legacy_wand_disconnected_error_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.gen_com_fault_IgnoreBool)
    Mock.gen_com_fault_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.gen_com_fault_CallInstance, cmock_line, "Function 'gen_com_fault' called less times than expected.");
  if (Mock.gen_com_fault_CallbackFunctionPointer != NULL)
    Mock.gen_com_fault_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.two_wand_disconnected_error_IgnoreBool)
    Mock.two_wand_disconnected_error_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.two_wand_disconnected_error_CallInstance, cmock_line, "Function 'two_wand_disconnected_error' called less times than expected.");
  if (Mock.two_wand_disconnected_error_CallbackFunctionPointer != NULL)
    Mock.two_wand_disconnected_error_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.multiple_button_pressed_test_IgnoreBool)
    Mock.multiple_button_pressed_test_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.multiple_button_pressed_test_CallInstance, cmock_line, "Function 'multiple_button_pressed_test' called less times than expected.");
  if (Mock.multiple_button_pressed_test_CallbackFunctionPointer != NULL)
    Mock.multiple_button_pressed_test_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.ui_fault_IgnoreBool)
    Mock.ui_fault_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.ui_fault_CallInstance, cmock_line, "Function 'ui_fault' called less times than expected.");
  if (Mock.ui_fault_CallbackFunctionPointer != NULL)
    Mock.ui_fault_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.smart_wand_incompatible_error_IgnoreBool)
    Mock.smart_wand_incompatible_error_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.smart_wand_incompatible_error_CallInstance, cmock_line, "Function 'smart_wand_incompatible_error' called less times than expected.");
  if (Mock.smart_wand_incompatible_error_CallbackFunctionPointer != NULL)
    Mock.smart_wand_incompatible_error_CallInstance = CMOCK_GUTS_NONE;
}

void Mocknotifications_Init(void)
{
  Mocknotifications_Destroy();
}

void Mocknotifications_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
  Mock.notification_manager_CallbackFunctionPointer = NULL;
  Mock.notification_manager_CallbackCalls = 0;
  Mock.gui_com_fault_CallbackFunctionPointer = NULL;
  Mock.gui_com_fault_CallbackCalls = 0;
  Mock.peak_hit_cntr_CallbackFunctionPointer = NULL;
  Mock.peak_hit_cntr_CallbackCalls = 0;
  Mock.legacy_wand_short_error_CallbackFunctionPointer = NULL;
  Mock.legacy_wand_short_error_CallbackCalls = 0;
  Mock.reset_error_CallbackFunctionPointer = NULL;
  Mock.reset_error_CallbackCalls = 0;
  Mock.suction_tube_error_CallbackFunctionPointer = NULL;
  Mock.suction_tube_error_CallbackCalls = 0;
  Mock.no_ambient_error_CallbackFunctionPointer = NULL;
  Mock.no_ambient_error_CallbackCalls = 0;
  Mock.clear_internal_temp_error_CallbackFunctionPointer = NULL;
  Mock.clear_internal_temp_error_CallbackCalls = 0;
  Mock.internal_temp_error_CallbackFunctionPointer = NULL;
  Mock.internal_temp_error_CallbackCalls = 0;
  Mock.adc_boundary_fault_CallbackFunctionPointer = NULL;
  Mock.adc_boundary_fault_CallbackCalls = 0;
  Mock.crc_fault_CallbackFunctionPointer = NULL;
  Mock.crc_fault_CallbackCalls = 0;
  Mock.wand_switch_stuck_fault_CallbackFunctionPointer = NULL;
  Mock.wand_switch_stuck_fault_CallbackCalls = 0;
  Mock.fp_switch_stuck_fault_CallbackFunctionPointer = NULL;
  Mock.fp_switch_stuck_fault_CallbackCalls = 0;
  Mock.pump_fault_CallbackFunctionPointer = NULL;
  Mock.pump_fault_CallbackCalls = 0;
  Mock.vmod_fault_CallbackFunctionPointer = NULL;
  Mock.vmod_fault_CallbackCalls = 0;
  Mock.can_timeout_CallbackFunctionPointer = NULL;
  Mock.can_timeout_CallbackCalls = 0;
  Mock.internal_temp_fault_CallbackFunctionPointer = NULL;
  Mock.internal_temp_fault_CallbackCalls = 0;
  Mock.wdog_fault_CallbackFunctionPointer = NULL;
  Mock.wdog_fault_CallbackCalls = 0;
  Mock.fault_init_CallbackFunctionPointer = NULL;
  Mock.fault_init_CallbackCalls = 0;
  Mock.date_time_fault_CallbackFunctionPointer = NULL;
  Mock.date_time_fault_CallbackCalls = 0;
  Mock.serial_num_fault_CallbackFunctionPointer = NULL;
  Mock.serial_num_fault_CallbackCalls = 0;
  Mock.wand_expired_error_CallbackFunctionPointer = NULL;
  Mock.wand_expired_error_CallbackCalls = 0;
  Mock.wand_use_limit_error_CallbackFunctionPointer = NULL;
  Mock.wand_use_limit_error_CallbackCalls = 0;
  Mock.clear_wand_expired_error_CallbackFunctionPointer = NULL;
  Mock.clear_wand_expired_error_CallbackCalls = 0;
  Mock.clear_wand_use_limit_error_CallbackFunctionPointer = NULL;
  Mock.clear_wand_use_limit_error_CallbackCalls = 0;
  Mock.wand_id_error_CallbackFunctionPointer = NULL;
  Mock.wand_id_error_CallbackCalls = 0;
  Mock.lw_id_error_CallbackFunctionPointer = NULL;
  Mock.lw_id_error_CallbackCalls = 0;
  Mock.wand_disconnected_error_CallbackFunctionPointer = NULL;
  Mock.wand_disconnected_error_CallbackCalls = 0;
  Mock.check_electrode_error_CallbackFunctionPointer = NULL;
  Mock.check_electrode_error_CallbackCalls = 0;
  Mock.wand_error_type_decipher_CallbackFunctionPointer = NULL;
  Mock.wand_error_type_decipher_CallbackCalls = 0;
  Mock.clear_wand_errors_CallbackFunctionPointer = NULL;
  Mock.clear_wand_errors_CallbackCalls = 0;
  Mock.lw_incompatible_error_CallbackFunctionPointer = NULL;
  Mock.lw_incompatible_error_CallbackCalls = 0;
  Mock.legacy_wand_disconnected_error_CallbackFunctionPointer = NULL;
  Mock.legacy_wand_disconnected_error_CallbackCalls = 0;
  Mock.gen_com_fault_CallbackFunctionPointer = NULL;
  Mock.gen_com_fault_CallbackCalls = 0;
  Mock.two_wand_disconnected_error_CallbackFunctionPointer = NULL;
  Mock.two_wand_disconnected_error_CallbackCalls = 0;
  Mock.multiple_button_pressed_test_CallbackFunctionPointer = NULL;
  Mock.multiple_button_pressed_test_CallbackCalls = 0;
  Mock.ui_fault_CallbackFunctionPointer = NULL;
  Mock.ui_fault_CallbackCalls = 0;
  Mock.smart_wand_incompatible_error_CallbackFunctionPointer = NULL;
  Mock.smart_wand_incompatible_error_CallbackCalls = 0;
}

void notification_manager(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_notification_manager_CALL_INSTANCE* cmock_call_instance = (CMOCK_notification_manager_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.notification_manager_CallInstance);
  Mock.notification_manager_CallInstance = CMock_Guts_MemNext(Mock.notification_manager_CallInstance);
  if (Mock.notification_manager_CallbackFunctionPointer != NULL)
  {
    Mock.notification_manager_CallbackFunctionPointer(Mock.notification_manager_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'notification_manager' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.notification_manager_IgnoreBool)
  {
    return;
  }
}

void notification_manager_CMockIgnore(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_notification_manager_CALL_INSTANCE));
  CMOCK_notification_manager_CALL_INSTANCE* cmock_call_instance = (CMOCK_notification_manager_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.notification_manager_CallInstance = CMock_Guts_MemChain(Mock.notification_manager_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  Mock.notification_manager_IgnoreBool = (int)1;
}

void notification_manager_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_notification_manager_CALL_INSTANCE));
  CMOCK_notification_manager_CALL_INSTANCE* cmock_call_instance = (CMOCK_notification_manager_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.notification_manager_CallInstance = CMock_Guts_MemChain(Mock.notification_manager_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
}

void notification_manager_StubWithCallback(CMOCK_notification_manager_CALLBACK Callback)
{
  Mock.notification_manager_CallbackFunctionPointer = Callback;
}

uint8_t gui_com_fault(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gui_com_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_gui_com_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gui_com_fault_CallInstance);
  Mock.gui_com_fault_CallInstance = CMock_Guts_MemNext(Mock.gui_com_fault_CallInstance);
  if (Mock.gui_com_fault_CallbackFunctionPointer != NULL)
  {
    return Mock.gui_com_fault_CallbackFunctionPointer(Mock.gui_com_fault_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'gui_com_fault' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.gui_com_fault_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.gui_com_fault_FinalReturn;
    Mock.gui_com_fault_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void gui_com_fault_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gui_com_fault_CALL_INSTANCE));
  CMOCK_gui_com_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_gui_com_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.gui_com_fault_CallInstance = CMock_Guts_MemChain(Mock.gui_com_fault_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gui_com_fault_IgnoreBool = (int)1;
}

void gui_com_fault_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gui_com_fault_CALL_INSTANCE));
  CMOCK_gui_com_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_gui_com_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.gui_com_fault_CallInstance = CMock_Guts_MemChain(Mock.gui_com_fault_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void gui_com_fault_StubWithCallback(CMOCK_gui_com_fault_CALLBACK Callback)
{
  Mock.gui_com_fault_CallbackFunctionPointer = Callback;
}

uint8_t peak_hit_cntr(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_peak_hit_cntr_CALL_INSTANCE* cmock_call_instance = (CMOCK_peak_hit_cntr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.peak_hit_cntr_CallInstance);
  Mock.peak_hit_cntr_CallInstance = CMock_Guts_MemNext(Mock.peak_hit_cntr_CallInstance);
  if (Mock.peak_hit_cntr_CallbackFunctionPointer != NULL)
  {
    return Mock.peak_hit_cntr_CallbackFunctionPointer(Mock.peak_hit_cntr_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'peak_hit_cntr' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.peak_hit_cntr_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.peak_hit_cntr_FinalReturn;
    Mock.peak_hit_cntr_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void peak_hit_cntr_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_peak_hit_cntr_CALL_INSTANCE));
  CMOCK_peak_hit_cntr_CALL_INSTANCE* cmock_call_instance = (CMOCK_peak_hit_cntr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.peak_hit_cntr_CallInstance = CMock_Guts_MemChain(Mock.peak_hit_cntr_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.peak_hit_cntr_IgnoreBool = (int)1;
}

void peak_hit_cntr_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_peak_hit_cntr_CALL_INSTANCE));
  CMOCK_peak_hit_cntr_CALL_INSTANCE* cmock_call_instance = (CMOCK_peak_hit_cntr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.peak_hit_cntr_CallInstance = CMock_Guts_MemChain(Mock.peak_hit_cntr_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void peak_hit_cntr_StubWithCallback(CMOCK_peak_hit_cntr_CALLBACK Callback)
{
  Mock.peak_hit_cntr_CallbackFunctionPointer = Callback;
}

uint8_t legacy_wand_short_error(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_legacy_wand_short_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_legacy_wand_short_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.legacy_wand_short_error_CallInstance);
  Mock.legacy_wand_short_error_CallInstance = CMock_Guts_MemNext(Mock.legacy_wand_short_error_CallInstance);
  if (Mock.legacy_wand_short_error_CallbackFunctionPointer != NULL)
  {
    return Mock.legacy_wand_short_error_CallbackFunctionPointer(Mock.legacy_wand_short_error_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'legacy_wand_short_error' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.legacy_wand_short_error_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.legacy_wand_short_error_FinalReturn;
    Mock.legacy_wand_short_error_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void legacy_wand_short_error_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_legacy_wand_short_error_CALL_INSTANCE));
  CMOCK_legacy_wand_short_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_legacy_wand_short_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.legacy_wand_short_error_CallInstance = CMock_Guts_MemChain(Mock.legacy_wand_short_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.legacy_wand_short_error_IgnoreBool = (int)1;
}

void legacy_wand_short_error_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_legacy_wand_short_error_CALL_INSTANCE));
  CMOCK_legacy_wand_short_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_legacy_wand_short_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.legacy_wand_short_error_CallInstance = CMock_Guts_MemChain(Mock.legacy_wand_short_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void legacy_wand_short_error_StubWithCallback(CMOCK_legacy_wand_short_error_CALLBACK Callback)
{
  Mock.legacy_wand_short_error_CallbackFunctionPointer = Callback;
}

uint8_t reset_error(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_reset_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_reset_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.reset_error_CallInstance);
  Mock.reset_error_CallInstance = CMock_Guts_MemNext(Mock.reset_error_CallInstance);
  if (Mock.reset_error_CallbackFunctionPointer != NULL)
  {
    return Mock.reset_error_CallbackFunctionPointer(Mock.reset_error_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'reset_error' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.reset_error_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.reset_error_FinalReturn;
    Mock.reset_error_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void reset_error_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_reset_error_CALL_INSTANCE));
  CMOCK_reset_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_reset_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.reset_error_CallInstance = CMock_Guts_MemChain(Mock.reset_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.reset_error_IgnoreBool = (int)1;
}

void reset_error_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_reset_error_CALL_INSTANCE));
  CMOCK_reset_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_reset_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.reset_error_CallInstance = CMock_Guts_MemChain(Mock.reset_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void reset_error_StubWithCallback(CMOCK_reset_error_CALLBACK Callback)
{
  Mock.reset_error_CallbackFunctionPointer = Callback;
}

uint8_t suction_tube_error(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_suction_tube_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_suction_tube_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.suction_tube_error_CallInstance);
  Mock.suction_tube_error_CallInstance = CMock_Guts_MemNext(Mock.suction_tube_error_CallInstance);
  if (Mock.suction_tube_error_CallbackFunctionPointer != NULL)
  {
    return Mock.suction_tube_error_CallbackFunctionPointer(Mock.suction_tube_error_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'suction_tube_error' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.suction_tube_error_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.suction_tube_error_FinalReturn;
    Mock.suction_tube_error_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void suction_tube_error_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_suction_tube_error_CALL_INSTANCE));
  CMOCK_suction_tube_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_suction_tube_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.suction_tube_error_CallInstance = CMock_Guts_MemChain(Mock.suction_tube_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.suction_tube_error_IgnoreBool = (int)1;
}

void suction_tube_error_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_suction_tube_error_CALL_INSTANCE));
  CMOCK_suction_tube_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_suction_tube_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.suction_tube_error_CallInstance = CMock_Guts_MemChain(Mock.suction_tube_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void suction_tube_error_StubWithCallback(CMOCK_suction_tube_error_CALLBACK Callback)
{
  Mock.suction_tube_error_CallbackFunctionPointer = Callback;
}

uint8_t no_ambient_error(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_no_ambient_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_no_ambient_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.no_ambient_error_CallInstance);
  Mock.no_ambient_error_CallInstance = CMock_Guts_MemNext(Mock.no_ambient_error_CallInstance);
  if (Mock.no_ambient_error_CallbackFunctionPointer != NULL)
  {
    return Mock.no_ambient_error_CallbackFunctionPointer(Mock.no_ambient_error_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'no_ambient_error' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.no_ambient_error_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.no_ambient_error_FinalReturn;
    Mock.no_ambient_error_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void no_ambient_error_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_no_ambient_error_CALL_INSTANCE));
  CMOCK_no_ambient_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_no_ambient_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.no_ambient_error_CallInstance = CMock_Guts_MemChain(Mock.no_ambient_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.no_ambient_error_IgnoreBool = (int)1;
}

void no_ambient_error_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_no_ambient_error_CALL_INSTANCE));
  CMOCK_no_ambient_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_no_ambient_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.no_ambient_error_CallInstance = CMock_Guts_MemChain(Mock.no_ambient_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void no_ambient_error_StubWithCallback(CMOCK_no_ambient_error_CALLBACK Callback)
{
  Mock.no_ambient_error_CallbackFunctionPointer = Callback;
}

uint8_t clear_internal_temp_error(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_clear_internal_temp_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_clear_internal_temp_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.clear_internal_temp_error_CallInstance);
  Mock.clear_internal_temp_error_CallInstance = CMock_Guts_MemNext(Mock.clear_internal_temp_error_CallInstance);
  if (Mock.clear_internal_temp_error_CallbackFunctionPointer != NULL)
  {
    return Mock.clear_internal_temp_error_CallbackFunctionPointer(Mock.clear_internal_temp_error_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'clear_internal_temp_error' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.clear_internal_temp_error_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.clear_internal_temp_error_FinalReturn;
    Mock.clear_internal_temp_error_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void clear_internal_temp_error_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_clear_internal_temp_error_CALL_INSTANCE));
  CMOCK_clear_internal_temp_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_clear_internal_temp_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.clear_internal_temp_error_CallInstance = CMock_Guts_MemChain(Mock.clear_internal_temp_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.clear_internal_temp_error_IgnoreBool = (int)1;
}

void clear_internal_temp_error_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_clear_internal_temp_error_CALL_INSTANCE));
  CMOCK_clear_internal_temp_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_clear_internal_temp_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.clear_internal_temp_error_CallInstance = CMock_Guts_MemChain(Mock.clear_internal_temp_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void clear_internal_temp_error_StubWithCallback(CMOCK_clear_internal_temp_error_CALLBACK Callback)
{
  Mock.clear_internal_temp_error_CallbackFunctionPointer = Callback;
}

uint8_t internal_temp_error(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_internal_temp_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_internal_temp_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.internal_temp_error_CallInstance);
  Mock.internal_temp_error_CallInstance = CMock_Guts_MemNext(Mock.internal_temp_error_CallInstance);
  if (Mock.internal_temp_error_CallbackFunctionPointer != NULL)
  {
    return Mock.internal_temp_error_CallbackFunctionPointer(Mock.internal_temp_error_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'internal_temp_error' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.internal_temp_error_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.internal_temp_error_FinalReturn;
    Mock.internal_temp_error_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void internal_temp_error_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_internal_temp_error_CALL_INSTANCE));
  CMOCK_internal_temp_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_internal_temp_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.internal_temp_error_CallInstance = CMock_Guts_MemChain(Mock.internal_temp_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.internal_temp_error_IgnoreBool = (int)1;
}

void internal_temp_error_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_internal_temp_error_CALL_INSTANCE));
  CMOCK_internal_temp_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_internal_temp_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.internal_temp_error_CallInstance = CMock_Guts_MemChain(Mock.internal_temp_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void internal_temp_error_StubWithCallback(CMOCK_internal_temp_error_CALLBACK Callback)
{
  Mock.internal_temp_error_CallbackFunctionPointer = Callback;
}

uint8_t adc_boundary_fault(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_adc_boundary_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_adc_boundary_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.adc_boundary_fault_CallInstance);
  Mock.adc_boundary_fault_CallInstance = CMock_Guts_MemNext(Mock.adc_boundary_fault_CallInstance);
  if (Mock.adc_boundary_fault_CallbackFunctionPointer != NULL)
  {
    return Mock.adc_boundary_fault_CallbackFunctionPointer(Mock.adc_boundary_fault_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'adc_boundary_fault' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.adc_boundary_fault_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.adc_boundary_fault_FinalReturn;
    Mock.adc_boundary_fault_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void adc_boundary_fault_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_adc_boundary_fault_CALL_INSTANCE));
  CMOCK_adc_boundary_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_adc_boundary_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.adc_boundary_fault_CallInstance = CMock_Guts_MemChain(Mock.adc_boundary_fault_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.adc_boundary_fault_IgnoreBool = (int)1;
}

void adc_boundary_fault_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_adc_boundary_fault_CALL_INSTANCE));
  CMOCK_adc_boundary_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_adc_boundary_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.adc_boundary_fault_CallInstance = CMock_Guts_MemChain(Mock.adc_boundary_fault_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void adc_boundary_fault_StubWithCallback(CMOCK_adc_boundary_fault_CALLBACK Callback)
{
  Mock.adc_boundary_fault_CallbackFunctionPointer = Callback;
}

uint8_t crc_fault(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_crc_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_crc_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.crc_fault_CallInstance);
  Mock.crc_fault_CallInstance = CMock_Guts_MemNext(Mock.crc_fault_CallInstance);
  if (Mock.crc_fault_CallbackFunctionPointer != NULL)
  {
    return Mock.crc_fault_CallbackFunctionPointer(Mock.crc_fault_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'crc_fault' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.crc_fault_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.crc_fault_FinalReturn;
    Mock.crc_fault_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void crc_fault_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_crc_fault_CALL_INSTANCE));
  CMOCK_crc_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_crc_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.crc_fault_CallInstance = CMock_Guts_MemChain(Mock.crc_fault_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.crc_fault_IgnoreBool = (int)1;
}

void crc_fault_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_crc_fault_CALL_INSTANCE));
  CMOCK_crc_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_crc_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.crc_fault_CallInstance = CMock_Guts_MemChain(Mock.crc_fault_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void crc_fault_StubWithCallback(CMOCK_crc_fault_CALLBACK Callback)
{
  Mock.crc_fault_CallbackFunctionPointer = Callback;
}

uint8_t wand_switch_stuck_fault(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_wand_switch_stuck_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_wand_switch_stuck_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.wand_switch_stuck_fault_CallInstance);
  Mock.wand_switch_stuck_fault_CallInstance = CMock_Guts_MemNext(Mock.wand_switch_stuck_fault_CallInstance);
  if (Mock.wand_switch_stuck_fault_CallbackFunctionPointer != NULL)
  {
    return Mock.wand_switch_stuck_fault_CallbackFunctionPointer(Mock.wand_switch_stuck_fault_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'wand_switch_stuck_fault' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.wand_switch_stuck_fault_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.wand_switch_stuck_fault_FinalReturn;
    Mock.wand_switch_stuck_fault_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void wand_switch_stuck_fault_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_wand_switch_stuck_fault_CALL_INSTANCE));
  CMOCK_wand_switch_stuck_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_wand_switch_stuck_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.wand_switch_stuck_fault_CallInstance = CMock_Guts_MemChain(Mock.wand_switch_stuck_fault_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.wand_switch_stuck_fault_IgnoreBool = (int)1;
}

void wand_switch_stuck_fault_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_wand_switch_stuck_fault_CALL_INSTANCE));
  CMOCK_wand_switch_stuck_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_wand_switch_stuck_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.wand_switch_stuck_fault_CallInstance = CMock_Guts_MemChain(Mock.wand_switch_stuck_fault_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void wand_switch_stuck_fault_StubWithCallback(CMOCK_wand_switch_stuck_fault_CALLBACK Callback)
{
  Mock.wand_switch_stuck_fault_CallbackFunctionPointer = Callback;
}

uint8_t fp_switch_stuck_fault(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_fp_switch_stuck_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_fp_switch_stuck_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.fp_switch_stuck_fault_CallInstance);
  Mock.fp_switch_stuck_fault_CallInstance = CMock_Guts_MemNext(Mock.fp_switch_stuck_fault_CallInstance);
  if (Mock.fp_switch_stuck_fault_CallbackFunctionPointer != NULL)
  {
    return Mock.fp_switch_stuck_fault_CallbackFunctionPointer(Mock.fp_switch_stuck_fault_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'fp_switch_stuck_fault' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.fp_switch_stuck_fault_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.fp_switch_stuck_fault_FinalReturn;
    Mock.fp_switch_stuck_fault_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void fp_switch_stuck_fault_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_fp_switch_stuck_fault_CALL_INSTANCE));
  CMOCK_fp_switch_stuck_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_fp_switch_stuck_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.fp_switch_stuck_fault_CallInstance = CMock_Guts_MemChain(Mock.fp_switch_stuck_fault_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.fp_switch_stuck_fault_IgnoreBool = (int)1;
}

void fp_switch_stuck_fault_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_fp_switch_stuck_fault_CALL_INSTANCE));
  CMOCK_fp_switch_stuck_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_fp_switch_stuck_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.fp_switch_stuck_fault_CallInstance = CMock_Guts_MemChain(Mock.fp_switch_stuck_fault_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void fp_switch_stuck_fault_StubWithCallback(CMOCK_fp_switch_stuck_fault_CALLBACK Callback)
{
  Mock.fp_switch_stuck_fault_CallbackFunctionPointer = Callback;
}

uint8_t pump_fault(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_pump_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_pump_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.pump_fault_CallInstance);
  Mock.pump_fault_CallInstance = CMock_Guts_MemNext(Mock.pump_fault_CallInstance);
  if (Mock.pump_fault_CallbackFunctionPointer != NULL)
  {
    return Mock.pump_fault_CallbackFunctionPointer(Mock.pump_fault_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'pump_fault' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.pump_fault_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.pump_fault_FinalReturn;
    Mock.pump_fault_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void pump_fault_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pump_fault_CALL_INSTANCE));
  CMOCK_pump_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_pump_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.pump_fault_CallInstance = CMock_Guts_MemChain(Mock.pump_fault_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.pump_fault_IgnoreBool = (int)1;
}

void pump_fault_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pump_fault_CALL_INSTANCE));
  CMOCK_pump_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_pump_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.pump_fault_CallInstance = CMock_Guts_MemChain(Mock.pump_fault_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void pump_fault_StubWithCallback(CMOCK_pump_fault_CALLBACK Callback)
{
  Mock.pump_fault_CallbackFunctionPointer = Callback;
}

uint8_t vmod_fault(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vmod_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_vmod_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vmod_fault_CallInstance);
  Mock.vmod_fault_CallInstance = CMock_Guts_MemNext(Mock.vmod_fault_CallInstance);
  if (Mock.vmod_fault_CallbackFunctionPointer != NULL)
  {
    return Mock.vmod_fault_CallbackFunctionPointer(Mock.vmod_fault_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'vmod_fault' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.vmod_fault_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.vmod_fault_FinalReturn;
    Mock.vmod_fault_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void vmod_fault_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vmod_fault_CALL_INSTANCE));
  CMOCK_vmod_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_vmod_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.vmod_fault_CallInstance = CMock_Guts_MemChain(Mock.vmod_fault_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.vmod_fault_IgnoreBool = (int)1;
}

void vmod_fault_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vmod_fault_CALL_INSTANCE));
  CMOCK_vmod_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_vmod_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.vmod_fault_CallInstance = CMock_Guts_MemChain(Mock.vmod_fault_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void vmod_fault_StubWithCallback(CMOCK_vmod_fault_CALLBACK Callback)
{
  Mock.vmod_fault_CallbackFunctionPointer = Callback;
}

uint8_t can_timeout(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_can_timeout_CALL_INSTANCE* cmock_call_instance = (CMOCK_can_timeout_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.can_timeout_CallInstance);
  Mock.can_timeout_CallInstance = CMock_Guts_MemNext(Mock.can_timeout_CallInstance);
  if (Mock.can_timeout_CallbackFunctionPointer != NULL)
  {
    return Mock.can_timeout_CallbackFunctionPointer(Mock.can_timeout_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'can_timeout' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.can_timeout_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.can_timeout_FinalReturn;
    Mock.can_timeout_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void can_timeout_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_can_timeout_CALL_INSTANCE));
  CMOCK_can_timeout_CALL_INSTANCE* cmock_call_instance = (CMOCK_can_timeout_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.can_timeout_CallInstance = CMock_Guts_MemChain(Mock.can_timeout_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.can_timeout_IgnoreBool = (int)1;
}

void can_timeout_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_can_timeout_CALL_INSTANCE));
  CMOCK_can_timeout_CALL_INSTANCE* cmock_call_instance = (CMOCK_can_timeout_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.can_timeout_CallInstance = CMock_Guts_MemChain(Mock.can_timeout_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void can_timeout_StubWithCallback(CMOCK_can_timeout_CALLBACK Callback)
{
  Mock.can_timeout_CallbackFunctionPointer = Callback;
}

uint8_t internal_temp_fault(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_internal_temp_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_internal_temp_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.internal_temp_fault_CallInstance);
  Mock.internal_temp_fault_CallInstance = CMock_Guts_MemNext(Mock.internal_temp_fault_CallInstance);
  if (Mock.internal_temp_fault_CallbackFunctionPointer != NULL)
  {
    return Mock.internal_temp_fault_CallbackFunctionPointer(Mock.internal_temp_fault_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'internal_temp_fault' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.internal_temp_fault_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.internal_temp_fault_FinalReturn;
    Mock.internal_temp_fault_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void internal_temp_fault_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_internal_temp_fault_CALL_INSTANCE));
  CMOCK_internal_temp_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_internal_temp_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.internal_temp_fault_CallInstance = CMock_Guts_MemChain(Mock.internal_temp_fault_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.internal_temp_fault_IgnoreBool = (int)1;
}

void internal_temp_fault_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_internal_temp_fault_CALL_INSTANCE));
  CMOCK_internal_temp_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_internal_temp_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.internal_temp_fault_CallInstance = CMock_Guts_MemChain(Mock.internal_temp_fault_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void internal_temp_fault_StubWithCallback(CMOCK_internal_temp_fault_CALLBACK Callback)
{
  Mock.internal_temp_fault_CallbackFunctionPointer = Callback;
}

uint8_t wdog_fault(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_wdog_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_wdog_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.wdog_fault_CallInstance);
  Mock.wdog_fault_CallInstance = CMock_Guts_MemNext(Mock.wdog_fault_CallInstance);
  if (Mock.wdog_fault_CallbackFunctionPointer != NULL)
  {
    return Mock.wdog_fault_CallbackFunctionPointer(Mock.wdog_fault_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'wdog_fault' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.wdog_fault_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.wdog_fault_FinalReturn;
    Mock.wdog_fault_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void wdog_fault_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_wdog_fault_CALL_INSTANCE));
  CMOCK_wdog_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_wdog_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.wdog_fault_CallInstance = CMock_Guts_MemChain(Mock.wdog_fault_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.wdog_fault_IgnoreBool = (int)1;
}

void wdog_fault_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_wdog_fault_CALL_INSTANCE));
  CMOCK_wdog_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_wdog_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.wdog_fault_CallInstance = CMock_Guts_MemChain(Mock.wdog_fault_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void wdog_fault_StubWithCallback(CMOCK_wdog_fault_CALLBACK Callback)
{
  Mock.wdog_fault_CallbackFunctionPointer = Callback;
}

uint8_t fault_init(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_fault_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_fault_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.fault_init_CallInstance);
  Mock.fault_init_CallInstance = CMock_Guts_MemNext(Mock.fault_init_CallInstance);
  if (Mock.fault_init_CallbackFunctionPointer != NULL)
  {
    return Mock.fault_init_CallbackFunctionPointer(Mock.fault_init_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'fault_init' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.fault_init_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.fault_init_FinalReturn;
    Mock.fault_init_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void fault_init_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_fault_init_CALL_INSTANCE));
  CMOCK_fault_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_fault_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.fault_init_CallInstance = CMock_Guts_MemChain(Mock.fault_init_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.fault_init_IgnoreBool = (int)1;
}

void fault_init_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_fault_init_CALL_INSTANCE));
  CMOCK_fault_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_fault_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.fault_init_CallInstance = CMock_Guts_MemChain(Mock.fault_init_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void fault_init_StubWithCallback(CMOCK_fault_init_CALLBACK Callback)
{
  Mock.fault_init_CallbackFunctionPointer = Callback;
}

uint8_t date_time_fault(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_date_time_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_date_time_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.date_time_fault_CallInstance);
  Mock.date_time_fault_CallInstance = CMock_Guts_MemNext(Mock.date_time_fault_CallInstance);
  if (Mock.date_time_fault_CallbackFunctionPointer != NULL)
  {
    return Mock.date_time_fault_CallbackFunctionPointer(Mock.date_time_fault_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'date_time_fault' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.date_time_fault_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.date_time_fault_FinalReturn;
    Mock.date_time_fault_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void date_time_fault_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_date_time_fault_CALL_INSTANCE));
  CMOCK_date_time_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_date_time_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.date_time_fault_CallInstance = CMock_Guts_MemChain(Mock.date_time_fault_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.date_time_fault_IgnoreBool = (int)1;
}

void date_time_fault_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_date_time_fault_CALL_INSTANCE));
  CMOCK_date_time_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_date_time_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.date_time_fault_CallInstance = CMock_Guts_MemChain(Mock.date_time_fault_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void date_time_fault_StubWithCallback(CMOCK_date_time_fault_CALLBACK Callback)
{
  Mock.date_time_fault_CallbackFunctionPointer = Callback;
}

uint8_t serial_num_fault(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_serial_num_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_serial_num_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.serial_num_fault_CallInstance);
  Mock.serial_num_fault_CallInstance = CMock_Guts_MemNext(Mock.serial_num_fault_CallInstance);
  if (Mock.serial_num_fault_CallbackFunctionPointer != NULL)
  {
    return Mock.serial_num_fault_CallbackFunctionPointer(Mock.serial_num_fault_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'serial_num_fault' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.serial_num_fault_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.serial_num_fault_FinalReturn;
    Mock.serial_num_fault_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void serial_num_fault_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_serial_num_fault_CALL_INSTANCE));
  CMOCK_serial_num_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_serial_num_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.serial_num_fault_CallInstance = CMock_Guts_MemChain(Mock.serial_num_fault_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.serial_num_fault_IgnoreBool = (int)1;
}

void serial_num_fault_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_serial_num_fault_CALL_INSTANCE));
  CMOCK_serial_num_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_serial_num_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.serial_num_fault_CallInstance = CMock_Guts_MemChain(Mock.serial_num_fault_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void serial_num_fault_StubWithCallback(CMOCK_serial_num_fault_CALLBACK Callback)
{
  Mock.serial_num_fault_CallbackFunctionPointer = Callback;
}

uint8_t wand_expired_error(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_wand_expired_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_wand_expired_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.wand_expired_error_CallInstance);
  Mock.wand_expired_error_CallInstance = CMock_Guts_MemNext(Mock.wand_expired_error_CallInstance);
  if (Mock.wand_expired_error_CallbackFunctionPointer != NULL)
  {
    return Mock.wand_expired_error_CallbackFunctionPointer(Mock.wand_expired_error_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'wand_expired_error' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.wand_expired_error_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.wand_expired_error_FinalReturn;
    Mock.wand_expired_error_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void wand_expired_error_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_wand_expired_error_CALL_INSTANCE));
  CMOCK_wand_expired_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_wand_expired_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.wand_expired_error_CallInstance = CMock_Guts_MemChain(Mock.wand_expired_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.wand_expired_error_IgnoreBool = (int)1;
}

void wand_expired_error_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_wand_expired_error_CALL_INSTANCE));
  CMOCK_wand_expired_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_wand_expired_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.wand_expired_error_CallInstance = CMock_Guts_MemChain(Mock.wand_expired_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void wand_expired_error_StubWithCallback(CMOCK_wand_expired_error_CALLBACK Callback)
{
  Mock.wand_expired_error_CallbackFunctionPointer = Callback;
}

uint8_t wand_use_limit_error(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_wand_use_limit_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_wand_use_limit_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.wand_use_limit_error_CallInstance);
  Mock.wand_use_limit_error_CallInstance = CMock_Guts_MemNext(Mock.wand_use_limit_error_CallInstance);
  if (Mock.wand_use_limit_error_CallbackFunctionPointer != NULL)
  {
    return Mock.wand_use_limit_error_CallbackFunctionPointer(Mock.wand_use_limit_error_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'wand_use_limit_error' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.wand_use_limit_error_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.wand_use_limit_error_FinalReturn;
    Mock.wand_use_limit_error_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void wand_use_limit_error_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_wand_use_limit_error_CALL_INSTANCE));
  CMOCK_wand_use_limit_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_wand_use_limit_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.wand_use_limit_error_CallInstance = CMock_Guts_MemChain(Mock.wand_use_limit_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.wand_use_limit_error_IgnoreBool = (int)1;
}

void wand_use_limit_error_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_wand_use_limit_error_CALL_INSTANCE));
  CMOCK_wand_use_limit_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_wand_use_limit_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.wand_use_limit_error_CallInstance = CMock_Guts_MemChain(Mock.wand_use_limit_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void wand_use_limit_error_StubWithCallback(CMOCK_wand_use_limit_error_CALLBACK Callback)
{
  Mock.wand_use_limit_error_CallbackFunctionPointer = Callback;
}

uint8_t clear_wand_expired_error(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_clear_wand_expired_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_clear_wand_expired_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.clear_wand_expired_error_CallInstance);
  Mock.clear_wand_expired_error_CallInstance = CMock_Guts_MemNext(Mock.clear_wand_expired_error_CallInstance);
  if (Mock.clear_wand_expired_error_CallbackFunctionPointer != NULL)
  {
    return Mock.clear_wand_expired_error_CallbackFunctionPointer(Mock.clear_wand_expired_error_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'clear_wand_expired_error' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.clear_wand_expired_error_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.clear_wand_expired_error_FinalReturn;
    Mock.clear_wand_expired_error_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void clear_wand_expired_error_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_clear_wand_expired_error_CALL_INSTANCE));
  CMOCK_clear_wand_expired_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_clear_wand_expired_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.clear_wand_expired_error_CallInstance = CMock_Guts_MemChain(Mock.clear_wand_expired_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.clear_wand_expired_error_IgnoreBool = (int)1;
}

void clear_wand_expired_error_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_clear_wand_expired_error_CALL_INSTANCE));
  CMOCK_clear_wand_expired_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_clear_wand_expired_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.clear_wand_expired_error_CallInstance = CMock_Guts_MemChain(Mock.clear_wand_expired_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void clear_wand_expired_error_StubWithCallback(CMOCK_clear_wand_expired_error_CALLBACK Callback)
{
  Mock.clear_wand_expired_error_CallbackFunctionPointer = Callback;
}

uint8_t clear_wand_use_limit_error(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_clear_wand_use_limit_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_clear_wand_use_limit_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.clear_wand_use_limit_error_CallInstance);
  Mock.clear_wand_use_limit_error_CallInstance = CMock_Guts_MemNext(Mock.clear_wand_use_limit_error_CallInstance);
  if (Mock.clear_wand_use_limit_error_CallbackFunctionPointer != NULL)
  {
    return Mock.clear_wand_use_limit_error_CallbackFunctionPointer(Mock.clear_wand_use_limit_error_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'clear_wand_use_limit_error' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.clear_wand_use_limit_error_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.clear_wand_use_limit_error_FinalReturn;
    Mock.clear_wand_use_limit_error_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void clear_wand_use_limit_error_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_clear_wand_use_limit_error_CALL_INSTANCE));
  CMOCK_clear_wand_use_limit_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_clear_wand_use_limit_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.clear_wand_use_limit_error_CallInstance = CMock_Guts_MemChain(Mock.clear_wand_use_limit_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.clear_wand_use_limit_error_IgnoreBool = (int)1;
}

void clear_wand_use_limit_error_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_clear_wand_use_limit_error_CALL_INSTANCE));
  CMOCK_clear_wand_use_limit_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_clear_wand_use_limit_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.clear_wand_use_limit_error_CallInstance = CMock_Guts_MemChain(Mock.clear_wand_use_limit_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void clear_wand_use_limit_error_StubWithCallback(CMOCK_clear_wand_use_limit_error_CALLBACK Callback)
{
  Mock.clear_wand_use_limit_error_CallbackFunctionPointer = Callback;
}

uint8_t wand_id_error(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_wand_id_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_wand_id_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.wand_id_error_CallInstance);
  Mock.wand_id_error_CallInstance = CMock_Guts_MemNext(Mock.wand_id_error_CallInstance);
  if (Mock.wand_id_error_CallbackFunctionPointer != NULL)
  {
    return Mock.wand_id_error_CallbackFunctionPointer(Mock.wand_id_error_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'wand_id_error' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.wand_id_error_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.wand_id_error_FinalReturn;
    Mock.wand_id_error_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void wand_id_error_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_wand_id_error_CALL_INSTANCE));
  CMOCK_wand_id_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_wand_id_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.wand_id_error_CallInstance = CMock_Guts_MemChain(Mock.wand_id_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.wand_id_error_IgnoreBool = (int)1;
}

void wand_id_error_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_wand_id_error_CALL_INSTANCE));
  CMOCK_wand_id_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_wand_id_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.wand_id_error_CallInstance = CMock_Guts_MemChain(Mock.wand_id_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void wand_id_error_StubWithCallback(CMOCK_wand_id_error_CALLBACK Callback)
{
  Mock.wand_id_error_CallbackFunctionPointer = Callback;
}

uint8_t lw_id_error(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lw_id_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_lw_id_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lw_id_error_CallInstance);
  Mock.lw_id_error_CallInstance = CMock_Guts_MemNext(Mock.lw_id_error_CallInstance);
  if (Mock.lw_id_error_CallbackFunctionPointer != NULL)
  {
    return Mock.lw_id_error_CallbackFunctionPointer(Mock.lw_id_error_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'lw_id_error' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.lw_id_error_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.lw_id_error_FinalReturn;
    Mock.lw_id_error_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void lw_id_error_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lw_id_error_CALL_INSTANCE));
  CMOCK_lw_id_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_lw_id_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.lw_id_error_CallInstance = CMock_Guts_MemChain(Mock.lw_id_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.lw_id_error_IgnoreBool = (int)1;
}

void lw_id_error_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lw_id_error_CALL_INSTANCE));
  CMOCK_lw_id_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_lw_id_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.lw_id_error_CallInstance = CMock_Guts_MemChain(Mock.lw_id_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void lw_id_error_StubWithCallback(CMOCK_lw_id_error_CALLBACK Callback)
{
  Mock.lw_id_error_CallbackFunctionPointer = Callback;
}

uint8_t wand_disconnected_error(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_wand_disconnected_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_wand_disconnected_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.wand_disconnected_error_CallInstance);
  Mock.wand_disconnected_error_CallInstance = CMock_Guts_MemNext(Mock.wand_disconnected_error_CallInstance);
  if (Mock.wand_disconnected_error_CallbackFunctionPointer != NULL)
  {
    return Mock.wand_disconnected_error_CallbackFunctionPointer(Mock.wand_disconnected_error_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'wand_disconnected_error' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.wand_disconnected_error_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.wand_disconnected_error_FinalReturn;
    Mock.wand_disconnected_error_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void wand_disconnected_error_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_wand_disconnected_error_CALL_INSTANCE));
  CMOCK_wand_disconnected_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_wand_disconnected_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.wand_disconnected_error_CallInstance = CMock_Guts_MemChain(Mock.wand_disconnected_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.wand_disconnected_error_IgnoreBool = (int)1;
}

void wand_disconnected_error_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_wand_disconnected_error_CALL_INSTANCE));
  CMOCK_wand_disconnected_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_wand_disconnected_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.wand_disconnected_error_CallInstance = CMock_Guts_MemChain(Mock.wand_disconnected_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void wand_disconnected_error_StubWithCallback(CMOCK_wand_disconnected_error_CALLBACK Callback)
{
  Mock.wand_disconnected_error_CallbackFunctionPointer = Callback;
}

uint8_t check_electrode_error(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_check_electrode_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_check_electrode_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.check_electrode_error_CallInstance);
  Mock.check_electrode_error_CallInstance = CMock_Guts_MemNext(Mock.check_electrode_error_CallInstance);
  if (Mock.check_electrode_error_CallbackFunctionPointer != NULL)
  {
    return Mock.check_electrode_error_CallbackFunctionPointer(Mock.check_electrode_error_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'check_electrode_error' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.check_electrode_error_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.check_electrode_error_FinalReturn;
    Mock.check_electrode_error_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void check_electrode_error_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_check_electrode_error_CALL_INSTANCE));
  CMOCK_check_electrode_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_check_electrode_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.check_electrode_error_CallInstance = CMock_Guts_MemChain(Mock.check_electrode_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.check_electrode_error_IgnoreBool = (int)1;
}

void check_electrode_error_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_check_electrode_error_CALL_INSTANCE));
  CMOCK_check_electrode_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_check_electrode_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.check_electrode_error_CallInstance = CMock_Guts_MemChain(Mock.check_electrode_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void check_electrode_error_StubWithCallback(CMOCK_check_electrode_error_CALLBACK Callback)
{
  Mock.check_electrode_error_CallbackFunctionPointer = Callback;
}

uint8_t wand_error_type_decipher(NOTIFY_TXT cmock_arg1)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_wand_error_type_decipher_CALL_INSTANCE* cmock_call_instance = (CMOCK_wand_error_type_decipher_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.wand_error_type_decipher_CallInstance);
  Mock.wand_error_type_decipher_CallInstance = CMock_Guts_MemNext(Mock.wand_error_type_decipher_CallInstance);
  if (Mock.wand_error_type_decipher_CallbackFunctionPointer != NULL)
  {
    return Mock.wand_error_type_decipher_CallbackFunctionPointer(cmock_arg1, Mock.wand_error_type_decipher_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'wand_error_type_decipher' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.wand_error_type_decipher_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.wand_error_type_decipher_FinalReturn;
    Mock.wand_error_type_decipher_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_cmock_arg1), (void*)(&cmock_arg1), sizeof(NOTIFY_TXT), cmock_line, "Function 'wand_error_type_decipher' called with unexpected value for argument 'cmock_arg1'.");
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_wand_error_type_decipher(CMOCK_wand_error_type_decipher_CALL_INSTANCE* cmock_call_instance, NOTIFY_TXT cmock_arg1)
{
  memcpy(&cmock_call_instance->Expected_cmock_arg1, &cmock_arg1, sizeof(NOTIFY_TXT));
}

void wand_error_type_decipher_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_wand_error_type_decipher_CALL_INSTANCE));
  CMOCK_wand_error_type_decipher_CALL_INSTANCE* cmock_call_instance = (CMOCK_wand_error_type_decipher_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.wand_error_type_decipher_CallInstance = CMock_Guts_MemChain(Mock.wand_error_type_decipher_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.wand_error_type_decipher_IgnoreBool = (int)1;
}

void wand_error_type_decipher_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, NOTIFY_TXT cmock_arg1, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_wand_error_type_decipher_CALL_INSTANCE));
  CMOCK_wand_error_type_decipher_CALL_INSTANCE* cmock_call_instance = (CMOCK_wand_error_type_decipher_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.wand_error_type_decipher_CallInstance = CMock_Guts_MemChain(Mock.wand_error_type_decipher_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_wand_error_type_decipher(cmock_call_instance, cmock_arg1);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void wand_error_type_decipher_StubWithCallback(CMOCK_wand_error_type_decipher_CALLBACK Callback)
{
  Mock.wand_error_type_decipher_CallbackFunctionPointer = Callback;
}

uint32_t clear_wand_errors(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_clear_wand_errors_CALL_INSTANCE* cmock_call_instance = (CMOCK_clear_wand_errors_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.clear_wand_errors_CallInstance);
  Mock.clear_wand_errors_CallInstance = CMock_Guts_MemNext(Mock.clear_wand_errors_CallInstance);
  if (Mock.clear_wand_errors_CallbackFunctionPointer != NULL)
  {
    return Mock.clear_wand_errors_CallbackFunctionPointer(Mock.clear_wand_errors_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'clear_wand_errors' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.clear_wand_errors_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.clear_wand_errors_FinalReturn;
    Mock.clear_wand_errors_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void clear_wand_errors_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_clear_wand_errors_CALL_INSTANCE));
  CMOCK_clear_wand_errors_CALL_INSTANCE* cmock_call_instance = (CMOCK_clear_wand_errors_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.clear_wand_errors_CallInstance = CMock_Guts_MemChain(Mock.clear_wand_errors_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.clear_wand_errors_IgnoreBool = (int)1;
}

void clear_wand_errors_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_clear_wand_errors_CALL_INSTANCE));
  CMOCK_clear_wand_errors_CALL_INSTANCE* cmock_call_instance = (CMOCK_clear_wand_errors_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.clear_wand_errors_CallInstance = CMock_Guts_MemChain(Mock.clear_wand_errors_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void clear_wand_errors_StubWithCallback(CMOCK_clear_wand_errors_CALLBACK Callback)
{
  Mock.clear_wand_errors_CallbackFunctionPointer = Callback;
}

uint8_t lw_incompatible_error(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lw_incompatible_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_lw_incompatible_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lw_incompatible_error_CallInstance);
  Mock.lw_incompatible_error_CallInstance = CMock_Guts_MemNext(Mock.lw_incompatible_error_CallInstance);
  if (Mock.lw_incompatible_error_CallbackFunctionPointer != NULL)
  {
    return Mock.lw_incompatible_error_CallbackFunctionPointer(Mock.lw_incompatible_error_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'lw_incompatible_error' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.lw_incompatible_error_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.lw_incompatible_error_FinalReturn;
    Mock.lw_incompatible_error_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void lw_incompatible_error_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lw_incompatible_error_CALL_INSTANCE));
  CMOCK_lw_incompatible_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_lw_incompatible_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.lw_incompatible_error_CallInstance = CMock_Guts_MemChain(Mock.lw_incompatible_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.lw_incompatible_error_IgnoreBool = (int)1;
}

void lw_incompatible_error_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lw_incompatible_error_CALL_INSTANCE));
  CMOCK_lw_incompatible_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_lw_incompatible_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.lw_incompatible_error_CallInstance = CMock_Guts_MemChain(Mock.lw_incompatible_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void lw_incompatible_error_StubWithCallback(CMOCK_lw_incompatible_error_CALLBACK Callback)
{
  Mock.lw_incompatible_error_CallbackFunctionPointer = Callback;
}

uint8_t legacy_wand_disconnected_error(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_legacy_wand_disconnected_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_legacy_wand_disconnected_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.legacy_wand_disconnected_error_CallInstance);
  Mock.legacy_wand_disconnected_error_CallInstance = CMock_Guts_MemNext(Mock.legacy_wand_disconnected_error_CallInstance);
  if (Mock.legacy_wand_disconnected_error_CallbackFunctionPointer != NULL)
  {
    return Mock.legacy_wand_disconnected_error_CallbackFunctionPointer(Mock.legacy_wand_disconnected_error_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'legacy_wand_disconnected_error' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.legacy_wand_disconnected_error_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.legacy_wand_disconnected_error_FinalReturn;
    Mock.legacy_wand_disconnected_error_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void legacy_wand_disconnected_error_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_legacy_wand_disconnected_error_CALL_INSTANCE));
  CMOCK_legacy_wand_disconnected_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_legacy_wand_disconnected_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.legacy_wand_disconnected_error_CallInstance = CMock_Guts_MemChain(Mock.legacy_wand_disconnected_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.legacy_wand_disconnected_error_IgnoreBool = (int)1;
}

void legacy_wand_disconnected_error_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_legacy_wand_disconnected_error_CALL_INSTANCE));
  CMOCK_legacy_wand_disconnected_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_legacy_wand_disconnected_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.legacy_wand_disconnected_error_CallInstance = CMock_Guts_MemChain(Mock.legacy_wand_disconnected_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void legacy_wand_disconnected_error_StubWithCallback(CMOCK_legacy_wand_disconnected_error_CALLBACK Callback)
{
  Mock.legacy_wand_disconnected_error_CallbackFunctionPointer = Callback;
}

uint8_t gen_com_fault(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gen_com_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_gen_com_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gen_com_fault_CallInstance);
  Mock.gen_com_fault_CallInstance = CMock_Guts_MemNext(Mock.gen_com_fault_CallInstance);
  if (Mock.gen_com_fault_CallbackFunctionPointer != NULL)
  {
    return Mock.gen_com_fault_CallbackFunctionPointer(Mock.gen_com_fault_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'gen_com_fault' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.gen_com_fault_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.gen_com_fault_FinalReturn;
    Mock.gen_com_fault_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void gen_com_fault_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gen_com_fault_CALL_INSTANCE));
  CMOCK_gen_com_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_gen_com_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.gen_com_fault_CallInstance = CMock_Guts_MemChain(Mock.gen_com_fault_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gen_com_fault_IgnoreBool = (int)1;
}

void gen_com_fault_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gen_com_fault_CALL_INSTANCE));
  CMOCK_gen_com_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_gen_com_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.gen_com_fault_CallInstance = CMock_Guts_MemChain(Mock.gen_com_fault_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void gen_com_fault_StubWithCallback(CMOCK_gen_com_fault_CALLBACK Callback)
{
  Mock.gen_com_fault_CallbackFunctionPointer = Callback;
}

uint8_t two_wand_disconnected_error(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_two_wand_disconnected_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_two_wand_disconnected_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.two_wand_disconnected_error_CallInstance);
  Mock.two_wand_disconnected_error_CallInstance = CMock_Guts_MemNext(Mock.two_wand_disconnected_error_CallInstance);
  if (Mock.two_wand_disconnected_error_CallbackFunctionPointer != NULL)
  {
    return Mock.two_wand_disconnected_error_CallbackFunctionPointer(Mock.two_wand_disconnected_error_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'two_wand_disconnected_error' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.two_wand_disconnected_error_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.two_wand_disconnected_error_FinalReturn;
    Mock.two_wand_disconnected_error_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void two_wand_disconnected_error_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_two_wand_disconnected_error_CALL_INSTANCE));
  CMOCK_two_wand_disconnected_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_two_wand_disconnected_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.two_wand_disconnected_error_CallInstance = CMock_Guts_MemChain(Mock.two_wand_disconnected_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.two_wand_disconnected_error_IgnoreBool = (int)1;
}

void two_wand_disconnected_error_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_two_wand_disconnected_error_CALL_INSTANCE));
  CMOCK_two_wand_disconnected_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_two_wand_disconnected_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.two_wand_disconnected_error_CallInstance = CMock_Guts_MemChain(Mock.two_wand_disconnected_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void two_wand_disconnected_error_StubWithCallback(CMOCK_two_wand_disconnected_error_CALLBACK Callback)
{
  Mock.two_wand_disconnected_error_CallbackFunctionPointer = Callback;
}

uint32_t multiple_button_pressed_test(uint32_t cmock_arg1)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_multiple_button_pressed_test_CALL_INSTANCE* cmock_call_instance = (CMOCK_multiple_button_pressed_test_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.multiple_button_pressed_test_CallInstance);
  Mock.multiple_button_pressed_test_CallInstance = CMock_Guts_MemNext(Mock.multiple_button_pressed_test_CallInstance);
  if (Mock.multiple_button_pressed_test_CallbackFunctionPointer != NULL)
  {
    return Mock.multiple_button_pressed_test_CallbackFunctionPointer(cmock_arg1, Mock.multiple_button_pressed_test_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'multiple_button_pressed_test' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.multiple_button_pressed_test_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.multiple_button_pressed_test_FinalReturn;
    Mock.multiple_button_pressed_test_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_cmock_arg1, cmock_arg1, cmock_line, "Function 'multiple_button_pressed_test' called with unexpected value for argument 'cmock_arg1'.");
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_multiple_button_pressed_test(CMOCK_multiple_button_pressed_test_CALL_INSTANCE* cmock_call_instance, uint32_t cmock_arg1)
{
  cmock_call_instance->Expected_cmock_arg1 = cmock_arg1;
}

void multiple_button_pressed_test_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_multiple_button_pressed_test_CALL_INSTANCE));
  CMOCK_multiple_button_pressed_test_CALL_INSTANCE* cmock_call_instance = (CMOCK_multiple_button_pressed_test_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.multiple_button_pressed_test_CallInstance = CMock_Guts_MemChain(Mock.multiple_button_pressed_test_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.multiple_button_pressed_test_IgnoreBool = (int)1;
}

void multiple_button_pressed_test_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_arg1, uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_multiple_button_pressed_test_CALL_INSTANCE));
  CMOCK_multiple_button_pressed_test_CALL_INSTANCE* cmock_call_instance = (CMOCK_multiple_button_pressed_test_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.multiple_button_pressed_test_CallInstance = CMock_Guts_MemChain(Mock.multiple_button_pressed_test_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_multiple_button_pressed_test(cmock_call_instance, cmock_arg1);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void multiple_button_pressed_test_StubWithCallback(CMOCK_multiple_button_pressed_test_CALLBACK Callback)
{
  Mock.multiple_button_pressed_test_CallbackFunctionPointer = Callback;
}

uint8_t ui_fault(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ui_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_ui_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ui_fault_CallInstance);
  Mock.ui_fault_CallInstance = CMock_Guts_MemNext(Mock.ui_fault_CallInstance);
  if (Mock.ui_fault_CallbackFunctionPointer != NULL)
  {
    return Mock.ui_fault_CallbackFunctionPointer(Mock.ui_fault_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'ui_fault' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.ui_fault_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.ui_fault_FinalReturn;
    Mock.ui_fault_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void ui_fault_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ui_fault_CALL_INSTANCE));
  CMOCK_ui_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_ui_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.ui_fault_CallInstance = CMock_Guts_MemChain(Mock.ui_fault_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.ui_fault_IgnoreBool = (int)1;
}

void ui_fault_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ui_fault_CALL_INSTANCE));
  CMOCK_ui_fault_CALL_INSTANCE* cmock_call_instance = (CMOCK_ui_fault_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.ui_fault_CallInstance = CMock_Guts_MemChain(Mock.ui_fault_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void ui_fault_StubWithCallback(CMOCK_ui_fault_CALLBACK Callback)
{
  Mock.ui_fault_CallbackFunctionPointer = Callback;
}

uint8_t smart_wand_incompatible_error(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_smart_wand_incompatible_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_smart_wand_incompatible_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.smart_wand_incompatible_error_CallInstance);
  Mock.smart_wand_incompatible_error_CallInstance = CMock_Guts_MemNext(Mock.smart_wand_incompatible_error_CallInstance);
  if (Mock.smart_wand_incompatible_error_CallbackFunctionPointer != NULL)
  {
    return Mock.smart_wand_incompatible_error_CallbackFunctionPointer(Mock.smart_wand_incompatible_error_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'smart_wand_incompatible_error' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (Mock.smart_wand_incompatible_error_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return Mock.smart_wand_incompatible_error_FinalReturn;
    Mock.smart_wand_incompatible_error_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  return cmock_call_instance->ReturnVal;
}

void smart_wand_incompatible_error_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_smart_wand_incompatible_error_CALL_INSTANCE));
  CMOCK_smart_wand_incompatible_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_smart_wand_incompatible_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.smart_wand_incompatible_error_CallInstance = CMock_Guts_MemChain(Mock.smart_wand_incompatible_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.smart_wand_incompatible_error_IgnoreBool = (int)1;
}

void smart_wand_incompatible_error_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_smart_wand_incompatible_error_CALL_INSTANCE));
  CMOCK_smart_wand_incompatible_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_smart_wand_incompatible_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  Mock.smart_wand_incompatible_error_CallInstance = CMock_Guts_MemChain(Mock.smart_wand_incompatible_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void smart_wand_incompatible_error_StubWithCallback(CMOCK_smart_wand_incompatible_error_CALLBACK Callback)
{
  Mock.smart_wand_incompatible_error_CallbackFunctionPointer = Callback;
}

